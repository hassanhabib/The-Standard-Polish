# 2.1 Fundamentalne Serwisy (Broker-Neighboring)

## 2.1.0 Wprowadzenie

Usługi fundamentalne są pierwszym punktem kontaktu pomiędzy logiką biznesową użytkownika a brokerami.

Ogólnie rzecz biorąc, usługi sąsiadujące z brokerami są hybrydą logiki biznesowej i warstwą abstrakcji dla operacji przetwarzania, w których dzieje się logika biznesowa wyższego rzędu, o której będziemy mówić dalej, gdy zaczniemy badać usługi przetwarzania w następnym rozdziale.

Usługi brokerskie są odpowiedzialne za zapewnienie, że dane przychodzące i wychodzące przez system są zatwierdzone i zweryfikowane strukturalnie, logicznie i zewnętrznie.

Możesz również myśleć o usługach brokerskich jako o warstwie walidacji na wierzchu prymitywnych operacji, które brokerzy już oferują.

Na przykład, jeśli broker pamięci masowej oferuje `InsertStudentAsync(Student student)` jako metodę, to usługa broker-neighboring zaoferuje coś następującego:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
}
```

Sprawia to, że usługi brokerów-sąsiadów są niczym więcej niż dodatkową warstwą walidacji na szczycie istniejących prymitywnych operacji, które brokerzy już oferują.

## 2.1.1 Na mapie

Usługi broker-neighboring rezydują pomiędzy twoimi brokerami a resztą twojej aplikacji, po lewej stronie mogą mieszkać usługi przetwarzania logiki biznesowej wyższego rzędu, orkiestracji, koordynacji, agregacji lub zarządzania, albo po prostu kontroler, komponent UI lub jakakolwiek inna technologia ekspozycji danych.

<br/>
	<p align=center>
		<img src="https://user-images.githubusercontent.com/1453985/100716772-00eec800-336e-11eb-9064-8bfe2f8e3be2.png" />
	</p>
<br/>

## 2.1.2 Charakterystyka

Usługi Foundation czy Broker-Neighboring w ogólności mają bardzo specyficzne cechy, które ściśle regulują ich rozwój i integrację.

Usługi Foundation generalnie skupiają się bardziej na walidacji niż na czymkolwiek innym - po prostu dlatego, że taki jest ich cel, aby zapewnić, że wszystkie przychodzące i wychodzące przez system dane są w dobrym stanie, aby system mógł je bezpiecznie przetwarzać bez żadnych problemów.

Oto charakterystyka i zasady, które rządzą usługami broker-neighboring:

### 2.1.2.0 Pure-Primitive

Usługi broker-neighboring nie mogą łączyć wielu prymitywnych operacji w celu uzyskania operacji logiki biznesowej wyższego rzędu.

Na przykład, usługi broker-neighboring nie mogą oferować funkcji _upsert_, aby połączyć operacje `Select` z operacjami `Update` lub `Insert` w oparciu o wynik, aby zapewnić, że podmiot istnieje i jest aktualny w każdym magazynie.

Ale oferują walidację i obsługę wyjątków (i mapowanie) wrapper wokół wywołań zależności, oto przykład:

```csharp
public ValueTask<Student> AddStudentAsync(Student student) =>.
TryCatch(async () =>.
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

W powyższej metodzie widać wywołanie funkcji `ValidateStudent` poprzedzone blokiem `TryCatch`.
Blok `TryCatch` jest tym, co nazywam wzorcem Exception Noise Cancellation, który omówimy wkrótce w tym właśnie rozdziale.

Funkcja sprawdzania poprawności zapewnia, że każda właściwość w przychodzących danych jest sprawdzana przed przekazaniem jej do prymitywnej operacji brokera, którą jest `InsertStudentAsync` w tym właśnie przypadku.

### 2.1.2.1 Integracja pojedynczego podmiotu

Usługi silnie zapewniają wdrożenie zasady pojedynczej odpowiedzialności poprzez brak integracji z innymi brokerami encji poza tym, który obsługuje.

Ta zasada nie musi dotyczyć brokerów wspierających takich jak `DateTimeBroker` czy `LoggingBroker`, ponieważ nie są one specjalnie ukierunkowane na żaden konkretny podmiot gospodarczy i są niemal ogólne w całym systemie.

Na przykład, `StudentService` może integrować się z `StorageBroker` tak długo, jak długo celuje tylko w funkcjonalność oferowaną przez klasę częściową w pliku `StorageBroker.Students.cs`.

Usługi Fundacji nie powinny integrować się z więcej niż jednym brokerem encji jakiegokolwiek rodzaju po prostu dlatego, że zwiększy to złożoność walidacji i orkiestracji, która wykracza poza główny cel usługi, którym jest po prostu walidacja. Przesuwamy tę odpowiedzialność dalej do usług typu orkiestracji, aby je obsłużyć.

### 2.1.2.2 Język biznesowy

Usługi sąsiadujące z Brokerem mówią prymitywnym językiem biznesowym dla swoich operacji.
Na przykład, podczas gdy Broker może dostarczyć metodę o nazwie `InsertStudentAsync` - odpowiednikiem tego w warstwie usług będzie `AddStudentAsync`.

Ogólnie rzecz biorąc, większość operacji CRUD jest konwertowana z języka przechowywania na język biznesowy, to samo dotyczy operacji nie przechowujących danych, takich jak kolejki, na przykład mówimy `PostQueueMessage`, ale w warstwie biznesowej powiemy `EnqueueMessage`.

Ponieważ operacje CRUD najczęstsze w każdym systemie, nasze mapowanie do tych operacji CRUD byłoby następujące:

| Brokerzy | Serwisy |.
| ------- | :------: 
| Insert | Add | | Select | Retrieve
| Wybierz | Odzyskaj | | Odbierz
| Aktualizuj | Modyfikuj
| Usunąć | Usunąć | Usunąć

W miarę jak posuwamy się naprzód w kierunku usług logiki biznesowej wyższego rzędu, język używanych metod będzie skłaniał się bardziej ku językowi biznesowemu niż technologicznemu, jak zobaczymy w kolejnych rozdziałach.

## 2.1.3 Odpowiedzialność

Usługi brokerskie odgrywają trzy bardzo ważne role w każdym systemie.
Pierwszą rolą jest abstrahowanie natywnych operacji brokera od reszty systemu. Niezależnie od tego, czy broker jest komunikacją pomiędzy lokalnym lub zewnętrznym magazynem, czy też API - usługi brokera-sąsiada zawsze będą miały ten sam kontrakt/wersję do ekspozycji na usługi górnego strumienia, takie jak przetwarzanie, orkiestracja lub po prostu eksponenty takie jak kontrolery lub komponenty UI.
Drugą i najważniejszą rolą jest oferowanie warstwy walidacji na szczycie istniejących prymitywnych operacji, które broker już oferuje, aby zapewnić, że przychodzące i wychodzące dane są ważne, aby być przetwarzane lub utrzymywane przez system.
Trzecią rolą jest odgrywanie roli mapera wszystkich innych natywnych modeli i umów, które mogą być potrzebne do ukończenia danej operacji podczas interakcji z brokerem.
Usługi fundacji są ostatnim punktem abstrakcji pomiędzy podstawową logiką biznesową dowolnego systemu a resztą świata, omówmy te role szczegółowo.

### 2.1.3.0 Abstrakcja

Pierwszym i najważniejszym obowiązkiem usług fundacji/brokerów-sąsiadów jest zapewnienie poziomu abstrakcji istniejącego pomiędzy brokerami a resztą twojego systemu. Abstrakcja ta jest niezbędna do zapewnienia, że warstwa czystej logiki biznesowej w każdym systemie jest werbalnie i funkcjonalnie agnostyczna w stosunku do wszelkich zależności, na których system opiera się w celu komunikacji ze światem zewnętrznym.

Zwizualizujmy konkretny przykład powyższej zasady. Załóżmy, że mamy `StudentProcessingService`, który implementuje funkcjonalność `UpsertStudentAsync`. Gdzieś w tej implementacji będzie zależność od `AddStudentAsync`, która jest eksponowana i implementowana przez jakiś `StudentService` jako usługa fundamentalna. Spójrz na ten snippet:

```csharp
public async ValueTask<Student> UpsertStudentAsync(Student Student)
{
	...

	return await this.studentService.AddStudentAsync(student);
}
```

Umowa między usługą przetwarzania lub usługą orkiestracji a usługą fundacji będzie zawsze taka sama niezależnie od tego, jaki typ implementacji lub jaki typ brokerów wykorzystuje usługa fundacji.
Na przykład, `AddStudentAsync` może być wywołaniem do bazy danych lub punktu końcowego API lub po prostu umieszczeniem wiadomości w kolejce. To wszystko nie wpływa w żaden sposób, kształt lub formę na implementację usługi przetwarzania upstream. oto przykład trzech różnych implementacji usługi fundacji, które nie zmieniłyby niczego w implementacji jej usług upstream:

Z brokerem pamięci masowej:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...
	return await this.storageBroker.InsertStudentAsync(student);
}
```

Lub z brokerem kolejki:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...

	return await this.queueBroker.EnqueueStudentAsync(student);
}
```

lub za pomocą brokera API:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student)
{
	...

	return await this.apiBroker.PostStudentAsync(student);
}
```

oto wizualizacja tej koncepcji:

<br />

<div align=center>.
	<img width="75%" src="https://user-images.githubusercontent.com/1453985/128610577-ee926ee2-a589-4f77-bf9d-dbff63d1c20d.png" />
</div>

<br />

We wszystkich powyższych przypadkach bazowa implementacja może się zmienić, ale odsłonięty kontrakt zawsze pozostanie taki sam dla reszty systemu. W późniejszych rozdziałach omówimy, w jaki sposób podstawowa, agnostyczna i abstreaktywna logika biznesowa twojego systemu zaczyna się od usług Processing i kończy na usługach Management lub Aggregation.

#### 2.1.3.0.1 Implementacja

Omówmy rzeczywisty przykład implementacji prostej funkcji `Add` w usłudze fundamentowej. Załóżmy, że mamy następujący kontrakt dla naszego `StudentService`:

```csharp
public IStudentService
{
	ValueTask<Student> AddStudentAsync(Student student);
}
```

Na początek pójdźmy dalej i napiszmy test zawodny dla naszej usługi w następujący sposób:

```csharp
public async Task ShouldAddStudentAsync()
{
	// dana
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	Student storageStudent = inputStudent;
	Student expectedStudent = storageStudent.DeepClone();

	this.storageBrokerMock.Setup(broker =>.
		broker.InsertStudentAsync(inputStudent))
			.ReturnsAsync(storageStudent);

	// kiedy
	Student actualStudent =.
		await this.studentService.AddStudentAsync(inputStudent);

	// then
	actualStudent.Should().BeEquivalentTo(expectedStudent);

	this.storageBroker.Verify(broker =>.
		broker.InsertStudentAsync(inputStudent),
			Times.Once);

	this.storageBroker.VerifyNoOtherCalls();
	this.loggingBroker.VerifyNoOtherCalls();
}
```

W powyższym teście zdefiniowaliśmy cztery zmienne o tej samej wartości. Każda zmienna zawiera nazwę, która najlepiej pasuje do kontekstu, w którym będzie używana. Na przykład `inputStudent` najlepiej pasuje do pozycji parametru wejściowego, natomiast `storageStudent` najlepiej najpierw to, co zostanie zwrócone z brokera storage po udanym persystowaniu studenta.

Zauważysz również, że głęboko sklonowaliśmy zmienną `expectedStudent`, aby upewnić się, że żadne modyfikacje nie zaszły w oryginalnie przekazanym studencie. Na przykład, załóżmy, że wartość wejściowa studenta została zmieniona dla któregokolwiek z jego atrybutów wewnątrz funkcji `AddStudentAsync`. Ta zmiana nie wywoła testu kończącego się niepowodzeniem, chyba że odwołamy się do zmiennej `expectedStudent` ze zmiennych wejściowych i zwróconych.

Wyśmiewamy odpowiedź z brokera pamięci masowej i wykonujemy nasz przedmiot testu `AddStudentAsync`, a następnie sprawdzamy, czy zwrócona wartość studenta `actualStudent` pasuje do oczekiwanej wartości `expectedStudent` bez względu na odniesienie.

Na koniec sprawdzamy, czy wszystkie wywołania zostały wykonane poprawnie i nie zostały wykonane żadne dodatkowe wywołania do żadnej z zależności usługowych.

Sprawmy, aby ten test przeszedł, pisząc w implementacji, która spełnia tylko wymagania wspomnianego testu:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student) =>.
	await this.storageBroker.InsertStudentAsync(student);
```

Ta prosta implementacja powinna sprawić, że nasz test przejdzie pomyślnie. Ważne jest, aby zrozumieć, że każda implementacja powinna być tylko wystarczająca, aby przejść przez nieudane testy. Nic więcej i nic mniej.

### 2.1.3.1 Walidacja

Usługi fundacji są wymagane, aby zapewnić przychodzące i wychodzące dane z i do systemu są w dobrym stanie - odgrywają rolę strażnika między systemem a światem zewnętrznym, aby zapewnić, że dane, które przechodzą, są strukturalnie, logicznie i zewnętrznie ważne przed wykonaniem jakichkolwiek dalszych operacji przez usługi upstream.
Kolejność walidacji jest tu bardzo celowa. Walidacje strukturalne są najtańsze z wszystkich trzech typów. Zapewniają one, że dany atrybut lub ogólnie kawałek danych nie ma wartości domyślnej, jeśli jest ona wymagana. przeciwieństwem tego są walidacje logiczne, gdzie atrybuty są porównywane z innymi atrybutami o tej samej encji lub jakiejkolwiek innej. Dodatkowe walidacje logiczne mogą również obejmować porównanie ze stałą wartością, jak porównanie wieku zapisu studenta, aby był nie mniejszy niż 5 lat.
Zarówno walidacje strucuralne, jak i logiczne pojawiają się przed zewnętrznymi. Jak powiedzieliśmy, to po prostu dlatego, że nie chcemy ponosić kosztów komunikacji z zasobem zewnętrznym, w tym podatku od opóźnień, jeśli nasze żądanie nie jest najpierw w dobrej formie.
Na przykład, nie powinniśmy próbować wysyłać jakiegoś obiektu `Student` do zewnętrznego API, jeśli obiekt jest `null`. Lub jeśli model `Student` jest nieważny strukturalnie lub logicznie.

Dla wszystkich typów walidacji ważne jest, aby zrozumieć, że niektóre walidacje są łamaniem obwodu lub wymagają natychmiastowego wyjścia z bieżącego przepływu poprzez rzucenie wyjątku lub zwrócenie wartości w niektórych przypadkach. A niektóre inne walidacje są ciągłe. Porozmawiajmy najpierw o tych dwóch podkategoriach walidacji.

#### 2.1.3.1.0 Walidacje łamiące obwody

Walidacje przerywające obieg wymagają natychmiastowego wyjścia z bieżącego przepływu. Na przykład, jeśli obiekt przekazywany do funkcji jest `null` - nie będzie żadnych dalszych operacji wymaganych na tym poziomie poza wyjściem z bieżącego przepływu poprzez rzucenie wyjątku lub zwrócenie wartości jakiegoś typu. Oto przykład:
W pewnym scenariuszu walidacji załóżmy, że nasza funkcja `AddStudent` ma studenta o wartości `null` przekazanego do niej w następujący sposób:

```csharp
Student noStudent = null;

await this.studentService.AddStudentAsync(noStudent);
```

Nasza funkcja `AddStudentAsync` w tym scenariuszu jest teraz wymagana do sprawdzenia, czy przekazany parametr jest `null` lub nie, zanim przejdzie dalej z jakimkolwiek innym typem walidacji lub samą logiką biznesową. Coś w tym stylu:

```csharp
public Student AddStudentAsync(Student Student) =>.
TryCatch(async () =>.
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

Oświadczeniem, na którym się skupiamy, jest funkcja `ValidateStudent` i to, co ona robi. Oto przykład tego, jak ta rutyna zostałaby zaimplementowana:

```csharp
private void ValidateStudent(Student student)
{
	if(student is null)
	{
		throw new NullStudentException();
	}
}
```

W powyższej funkcji postanowiliśmy od razu rzucić wyjątek, zamiast wchodzić dalej. To jest przykład walidacji typu circuit-breaking.

Ale w przypadku walidacji, łamanie obwodu nie zawsze jest mądrą rzeczą do zrobienia. Czasami chcemy zebrać wszystkie problemy w ramach danego żądania przed wysłaniem raportu o błędzie z powrotem do osoby składającej żądanie. Porozmawiajmy o tym w następnym rozdziale.

#### 2.1.3.1.1 Ciągłe walidacje

Walidacje ciągłe są przeciwieństwem walidacji przerywających obieg. Nie zatrzymują one przepływu walidacji, ale zdecydowanie zatrzymują przepływ logiki. Innymi słowy, ciągłe walidacje zapewniają, że żadna logika biznesowa nie zostanie wykonana, ale również zapewniają, że inne walidacje tego samego typu mogą kontynuować wykonywanie przed przerwaniem obwodu. Zmaterializujmy tę teorię na przykładzie:
Załóżmy, że nasz model ucznia wygląda tak:

```csharp
public class Student
{
	public Guid Id {get; set;}
	public string Name {get; set;}
}
```

Zakładając, że przekazany model `Student` nie jest zerowy, ale ma domyślne wartości dla wszystkich swoich właściwości. Chcemy zebrać wszystkie te kwestie dla dowolnej liczby atrybutów/właściwości, które posiada ten obiekt i zwrócić pełny raport z powrotem do requestera. Oto jak to zrobić.

#### 2.1.3.1.1.0 Wyjątki związane z Upsertable

Problem tego typu wymaga specjalnego typu wyjątków, które pozwalają na zebranie wszystkich błędów we właściwości `Data`. Każdy rodzimy wyjątek będzie zawierał właściwość `Data`, która jest w zasadzie słownikiem par klucz/wartość do zbierania więcej informacji o problemach, które spowodowały wystąpienie tego wyjątku.
Problem z tymi natywnymi wyjątkami polega na tym, że nie mają one natywnego wsparcia dla upsertion. Możliwość dołączenia do istniejącej listy wartości względem konkretnego klucza w dowolnym momencie.
Oto natywna implementacja upserting wartości w jakimś danym słowniku:

```csharp
var someException = new Exception();

if(someException.Data.Contains(someKey))
{
	(someException.Data[someKey] as List<string>)?.Add(someValue);
}
else
{
	someException.Data.Add(someKey, new List<string>{ someValue });
}
```

Ta implementacja może być dość zniechęcająca dla inżynierów do myślenia i testowania w ich implementacji na poziomie usług. Czułem się bardziej odpowiedni do wprowadzenia prostej biblioteki `Xeptions`, aby uprościć powyższą implementację w coś tak prostego jak:

```csharp
var someException = new Xeption();
someException.UpsertData(someKey, someValue);
```

Teraz, gdy mamy tę bibliotekę do wykorzystania, obawy dotyczące implementacji wyjątków upsertable zostały rozwiązane. Oznacza to, że mamy to, czego potrzeba, aby zebrać nasze błędy walidacji. Ale to nie jest wystarczająco dobre, jeśli nie mamy mechanizmu, aby przerwać obwód, gdy uważamy, że czas jest odpowiedni, aby to zrobić.
Możemy po prostu użyć natywnej oferty, aby bezpośrednio zaimplementować łamanie obwodu w następujący sposób:

```csharp
if(someException.Data.Count > 0)
{
	throw someException;
}
```

I chociaż to może być łatwo upieczone w każdej istniejącej implementacji. Nadal nie wnosiło to wiele do ogólnego wyglądu-n-feelu kodu. Dlatego postanowiłem uczynić go częścią biblioteki `Xeptions`, aby uprościć go do następującego:

```csharp
someException.ThrowIfContainsErrors();
```

Dzięki temu nasze niestandardowe walidacje wyglądałyby coś takiego:

```csharp
public class InvalidStudentException : Xeption
{
	public InvalidStudentException()
		: base ("Student jest nieważny, proszę poprawić błędy i spróbować ponownie.")
	{ }
}
```

Ale z ciągłymi walidacjami, proces zbierania tych błędów przekazuje więcej niż tylko specjalną implementację wyjątków. Porozmawiajmy o tym w następnej sekcji.

#### 2.1.3.1.1 Dynamiczne reguły

Nie łamiący obwodu lub ciągły proces walidacji będzie wymagał zdolności do przekazywania dynamicznych reguł przy dowolnym liczeniu lub pojemności, aby dodać te błędy walidacji. Reguła walidacji jest dynamiczną strukturą, która informuje, czy reguła została naruszona dla jej warunku; a także komunikat o błędzie, który powinien być zgłoszony do użytkownika końcowego, aby pomóc mu naprawić ten problem.

W scenariuszu, w którym chcemy zapewnić, że każdy dany Id jest ważny, dynamiczna ciągła reguła walidacji wyglądałaby coś takiego:

```csharp
private static dynamic IsInvalid(Guid id) => new
{
	Condition = id == Guid.Empty,
	Message = "Id jest wymagane"
};
```

Teraz nasza Reguła nie tylko informuje, czy dany atrybut jest nieważny, czy nie. Posiada również sensowny komunikat czytelny dla człowieka, który pomaga konsumentowi usługi zrozumieć, co sprawia, że właśnie ten atrybut jest nieważny.

To naprawdę ważne, aby zwrócić uwagę na język, którego inżynierowie muszą używać w komunikatach walidacyjnych. Wszystko będzie zależało od potencjalnych konsumentów twojego systemu. Nie-inżynier nie zrozumie komunikatu takiego jak `Text cannot be null, empty or whitespace` - `null` jako termin nie jest czymś, co jest bardzo powszechnie używane. Inżynierowie muszą ściśle współpracować z ich meatware (Ludzie używający systemu), aby zapewnić, że język ma dla nich sens.

Dynamiczne reguły pozwolą inżynierom modyfikować zarówno ich wejścia jak i wyjścia bez naruszania jakiejkolwiek istniejącej funkcjonalności tak długo jak wartości `null` będą brane pod uwagę w całym systemie. Oto inny przejaw dynamicznej reguły walidacji:

```csharp
private static dynamic IsNotSame(
	Guid firstId,
	Guid secondId,
	string secondIdName) => new
{
	Condition = firstId != secondId,
	Message = $"Id nie jest takie samo jak {secondIdName}.",
	HelpLink = "/help/code1234"
};
```

Nasza dynamiczna reguła może teraz zaoferować więcej parametrów wejściowych i więcej pomocnych informacji w postaci bardziej szczegółowego komunikatu o wyjątku z linkami do pomocnych stron dokumentacji lub referencji dla kodów błędów.

#### 2.1.3.1.2 Kolektor reguł i walidacji

Teraz, gdy mamy już zaawansowane wyjątki i dynamiczne reguły walidacji. Nadszedł czas, aby umieścić to wszystko razem w kategoriach akceptowania nieskończonej liczby reguł walidacji, badając ich wyniki warunkowe i ostatecznie przerwać obwód, gdy wszystkie ciągłe walidacje są wykonane. oto jak to zrobić:

```csharp
private void Validate(params (dynamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new InvalidStudentException();

	foreach((dynamic rule, string parameter) in validations)
	{
		if(rule.Condition)
		{
			invalidStudentException.UpsertData(parametr, rule.Message);
		}
	}

	invalidStudentException.ThrowIfContainsErrors();
}
```

Powyższa funkcja przyjmie teraz dowolną liczbę reguł walidacji, oraz parametry, przeciwko którym działa reguła, a następnie zbada warunki i upsertuje raport błędów. W ten sposób możemy użyć powyższej metody:

```csharp
private void ValidateStudent(Student student)
{
	Validate(
		(Rule: IsInvalid(student.Id), Parameter: nameof(Student.Id)),
		(Rule: IsInvalid(student.Name), Parameter: nameof(Student.name)),
		(Rule: IsInvalid(student.Grade), Parameter: nameof(Student.Grade))
	);
}
```

To uproszczenie pisania reguł i walidacji jest ostatecznym celem kontynuowania dostarczania wartości użytkownikom końcowym, jednocześnie czyniąc proces inżynierii rozwiązania przyjemnym dla samych inżynierów.

Teraz zanurkujmy głębiej w rodzaje walidacji, które mogą zaoferować nasze systemy i jak je obsługiwać.

#### 2.1.3.1.2 Walidacje strukturalne

Walidacje mają trzy różne warstwy. pierwszą z tych warstw są walidacje strukturalne. aby zapewnić, że pewne właściwości na danym modelu lub prymitywnym typie nie są w nieprawidłowym stanie strukturalnym.

Na przykład, właściwość typu `String` nie powinna być pusta, `null` lub biała spacja. innym przykładem może być parametr wejściowy typu `int`, nie powinien być w stanie `default` czyli `0` podczas próby wprowadzenia wieku na przykład.

Walidacje strukturalne zapewniają, że dane są w dobrym stanie przed przejściem do dalszych walidacji - na przykład, nie możemy sprawdzić, czy uczeń ma minimalną liczbę znaków (co jest logiczną walidacją) w swoim nazwisku, jeśli jego imię jest strukturalnie niepoprawne poprzez bycie `null`, puste lub z białymi spacjami.

Walidacje strukturalne odgrywają rolę identyfikacji _wymaganych_ właściwości na dowolnym modelu, i podczas gdy wiele technologii oferuje adnotacje walidacyjne, wtyczki lub biblioteki do globalnego egzekwowania reguł walidacji danych, wybieram wykonywanie walidacji programowo i ręcznie, aby uzyskać większą kontrolę nad tym, co byłoby wymagane, a co nie w modzie TDD.

Problem z niektórymi z obecnych implementacji na strukturalnych i logicznych walidacjach na modelach danych polega na tym, że można je bardzo łatwo zmienić pod radarem bez żadnych testów jednostkowych strzelających jakimikolwiek alarmami. Sprawdź na przykład ten przykład:

```csharp
public Student
{
	[Required]
	public string Name {get; set;}
}
```

Powyższy przykład może być bardzo kuszący na pierwszy rzut oka z inżynierskiego punktu widzenia. Wszystko, co musisz zrobić, to udekorować swój atrybut modelu magiczną adnotacją, a potem nagle twoje dane są walidowane.

Problem polega na tym, że ten wzór łączy dwie różne odpowiedzialności lub więcej razem w tym samym modelu. Modele mają być tylko reprezentacją obiektów w rzeczywistości - nic więcej i nic mniej. Niektórzy inżynierowie nazywają je modelami anemicznymi, które skupiają się na odpowiedzialności każdego modelu, aby reprezentować tylko atrybuty obiektu świata rzeczywistego, który próbuje symulować, bez żadnych dodatkowych szczegółów.

Ale modele adnotowane próbują teraz wstrzykiwać logikę biznesową do ich samych definicji. Ta logika biznesowa może być lub nie być potrzebna we wszystkich usługach, brokerach lub komponentach eksponujących, które ich używają.

Walidacje strukturalne na modelach mogą wydawać się dodatkową pracą, której można uniknąć za pomocą magicznych dekoracji. Ale w przypadku próby odejścia nieco od tych walidacji w kierunku bardziej niestandardowych walidacji, teraz zobaczysz nowy anty-wzór wyłaniający się jak niestandardowe adnotacje, które mogą lub nie mogą być wykryte przez testy jednostkowe.

Porozmawiajmy o tym, jak przetestować strukturalną rutynę walidacyjną:

##### 2.1.3.1.2.0 Testowanie walidacji strukturalnych.

Ponieważ naprawdę wierzę w znaczenie TDD, zamierzam zacząć pokazywać implementację walidacji strukturalnych poprzez napisanie najpierw nieudanego testu dla nich.

Załóżmy, że mamy model studenta, z następującymi szczegółami:

```csharp
public class "Student
{
	public Guid Id {get; set;}
}
```

Chcemy sprawdzić, czy Id studenta nie jest strukturalnie nieprawidłowym Id - takim jak pusty `Guid` - dlatego napisalibyśmy test jednostkowy w następujący sposób:

```csharp
[Fact]
public async void ShouldThrowValidationExceptionOnRegisterWhenIdIsInvalidAndLogItAsync()
{
	// dana
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	inputStudent.Id = Guid.Empty;

	var invalidStudentException = new InvalidStudentException();

	invalidStudentException.AddData(
		key: nameof(Student.Id),
		value: "Id jest wymagane"
	);

	var expectedStudentValidationException =.
		new StudentValidationException(invalidStudentException);

	// kiedy
	ValueTask<Student> registerStudentTask =.
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentValidationException actualStudentValidationException =.
		await Assert.ThrowsAsync<StudentValidationException>(
			registerStudentTask.AsTask);

	// następnie
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.loggingBrokerMock.Verify(broker =>.
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException)),
				Times.Once);

	this.storageBrokerMock.Verify(broker =>.
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Never);

	this.dateTimeBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.storageBrokerMock.VerifyNoOtherCalls();
}
```

W powyższym teście utworzyliśmy losowy obiekt studenta, a następnie przypisaliśmy niepoprawną wartość Id o wartości `Guid.Empty` do studenta `Id`.

Kiedy strukturalna logika walidacji w naszej usłudze fundacji bada właściwość `Id`, powinna rzucić właściwość wyjątku opisującą problem walidacji w naszym modelu studenta. w tym przypadku rzucamy `InvalidStudentException`.

Wyjątek jest wymagany, aby krótko opisać whats, wheres i whys operacji walidacji. w naszym przypadku co byłoby problemem walidacji występującym, gdzie byłby serwis Student i dlaczego byłoby wartością właściwości.

Oto jak wyglądałby wyjątek `InvalidStudentException`:

```csharp
public class InvalidStudentException : Xeption
{
	public InvalidStudentException()
		:base ("Student jest nieważny, proszę poprawić błędy i spróbować ponownie.")
	{ }
}
```

Powyższy test jednostkowy wymaga jednak, aby nasz `InvalidStudentException` został zawinięty w bardziej ogólny wyjątek na poziomie systemu, którym jest `StudentValidationException` - te wyjątki nazywam wyjątkami zewnętrznymi, hermetyzują one wszystkie różne sytuacje walidacji niezależnie od ich kategorii i komunikują błąd do usług upstream lub kontrolerów, aby mogły one zmapować to do odpowiedniego kodu błędu dla konsumenta tych usług.

Nasz `StudentValidationException` zostałby zaimplementowany w następujący sposób:

```csharp
public class StudentValidationException : Exception
{
	public StudentValidationException(Exception innerException)
		: base("Wystąpił błąd walidacji studenta, proszę sprawdzić dane wejściowe, a następnie spróbować ponownie.", innerException) { }
}
```

Komunikat w walidacji zewnętrznej powyżej wskazuje, że problem jest w danych wejściowych, a zatem wymaga, aby podmiot składający dane wejściowe spróbował ponownie, ponieważ nie ma żadnych działań wymaganych od strony systemu do dostosowania.

##### 2.1.3.1.2.1 Implementacja walidacji strukturalnych

Przyjrzyjmy się teraz drugiej stronie procesu walidacji, którą jest implementacja.
Walidacje strukturalne zawsze są przed każdym innym typem walidacji. To po prostu dlatego, że walidacje strukturalne są najtańsze z perspektywy wykonania i czasu asymptotycznego.
Na przykład, znacznie taniej jest zwalidować `Id` jako niepoprawny strukturalnie, niż wysyłać wywołanie API w poprzek, aby uzyskać dokładnie taką samą odpowiedź plus koszt opóźnienia. To wszystko dodaje się, gdy zaczyna napływać wiele milionów żądań na sekundę.
Strukturalne i logiczne walidacje w ogóle żyją w swoich własnych klasach częściowych, aby uruchomić te walidacje, na przykład, jeśli nasza usługa nazywa się `StudentService.cs` to nowy plik powinien być utworzony z nazwą `StudentService.Validations.cs`, aby hermetyzować i wizualnie abstrahować reguły walidacji, aby zapewnić, że czyste dane wchodzą i wychodzą.
Oto jak wyglądałaby walidacja Id:

###### StudentService.Validations.cs

```csharp

private void ValidateStudent(Student student)
{
	Validate((Rule: IsInvalid(student.Id), Parameter: nameof(Student.Id)));
}

private static dynamic IsInvalid(Guid id) => new.
{
	Condition = id == Guid.Empty,
	Message = "Id jest wymagane"
};

private void Validate(params (dynamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new InvalidStudentException();

	foreach((dynamic rule, string parameter) in validations)
	{
		if(rule.Condition)
		{
			invalidStudentException.UpsertData(parametr, rule.Message);
		}
	}

	invalidStudentException.ThrowIfContainsErrors();
}
```

Zaimplementowaliśmy metodę walidacji całego obiektu studenta, wraz z kompilacją wszystkich reguł, które musimy ustawić, aby walidować strukturalnie i logicznie obiekt wejściowy studenta. Najważniejszą częścią, którą należy zauważyć w powyższym fragmencie kodu, jest zapewnienie hermetyzacji wszelkich drobnych szczegółów znajdujących się z dala od głównego celu danej metody.

To jest powód, dla którego zdecydowaliśmy się zaimplementować prywatną statyczną metodę `IsInvalid`, aby wyabstrahować szczegóły tego, co decyduje o tym, że właściwość typu `Guid` jest nieważna lub nie. I w miarę jak będziemy posuwać się dalej w implementacji, będziemy musieli zaimplementować wiele przeciążeń tej samej metody, aby zatwierdzić inne typy wartości strukturalnie i logicznie.

Celem metody `ValidateStudent` jest po prostu ustawienie reguł i podjęcie akcji poprzez rzucenie wyjątku, jeśli któraś z tych reguł zostanie naruszona. Zawsze istnieje możliwość agregacji błędów naruszenia, zamiast rzucania zbyt wcześnie na pierwszy znak strukturalnego lub logicznego problemu walidacji do wykrycia.

Teraz, z powyższą implementacją, musimy wywołać tę metodę, aby strukturalnie i logicznie zatwierdzić nasze dane wejściowe. Wykonajmy to wywołanie w naszej metodzie `RegisterStudentAsync` w następujący sposób:

###### StudentService.cs

```csharp
public ValueTask<Student> RegisterStudentAsync(Student student) =>.
TryCatch(async () =>.
{
	ValidateStudent(student);

	return await this.storageBroker.InsertStudentAsync(student);
});
```

Na pierwszy rzut oka można zauważyć, że nasza metoda tutaj niekoniecznie obsługuje jakikolwiek typ wyjątków na poziomie logiki. Dzieje się tak dlatego, że cały szum związany z wyjątkami jest również wyabstrahowany w metodzie o nazwie `TryCatch`.

TryCatch` jest koncepcją, którą wymyśliłem, aby pozwolić inżynierom skupić się na tym, co ma największe znaczenie w zależności od tego, na jaki aspekt usługi patrzą, bez konieczności chodzenia na skróty z obsługą wyjątków, aby uczynić kod nieco bardziej czytelnym.

Metody `TryCatch` w ogóle żyją w innej klasie częściowej i w zupełnie nowym pliku o nazwie `StudentService.Exceptions.cs` - gdzie dzieje się cała obsługa wyjątków i raportowanie błędów, jak pokażę w poniższym przykładzie.

Przyjrzyjmy się, jak wygląda metoda `TryCatch`:

###### StudentService.Exceptions.cs

```csharp
private delegate ValueTask<Student> ReturningStudentFunction();

private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	catch (InvalidStudentException invalidStudentInputException)
	{
		throw CreateAndLogValidationException(invalidStudentInputException);
	}
}

private StudentValidationException CreateAndLogValidationException(Exception exception)
{
	var studentValidationException = new StudentValidationException(exception);
	this.loggingBroker.LogError(studentValidationException);

	return studentValidationException;
}
```

Wzorzec eliminacji wyjątków `TryCatch` pięknie przyjmuje dowolną funkcję zwracającą określony typ jako delegata i obsługuje wszelkie rzucone wyjątki z tej funkcji lub jej zależności.

Główną odpowiedzialnością funkcji `TryCatch` jest zawijanie wewnętrznych wyjątków usługi z zewnętrznymi wyjątkami, aby ułatwić reakcję zewnętrznych konsumentów tej usługi na tylko jedną z trzech kategorii, którymi są wyjątki usługi, wyjątki walidacji i wyjątki zależności. istnieją podtypy tych wyjątków, takie jak wyjątki walidacji zależności, ale zwykle należą one do kategorii wyjątków walidacji, jak omówimy w nadchodzących sekcjach Standardu.

W metodzie `TryCatch` możemy dodać tyle wyjątków wewnętrznych i zewnętrznych, ile chcemy, i odwzorować je na wyjątki lokalne, aby usługi upstream nie miały silnej zależności od konkretnych bibliotek lub modeli zasobów zewnętrznych, o czym szczegółowo porozmawiamy, gdy przejdziemy do odpowiedzialności za mapowanie usług broker-neighboring (fundacja).

#### 2.1.3.1.3 Walidacje logiczne

Walidacje logiczne są drugimi w kolejności po walidacjach strukturalnych. Ich głównym zadaniem z definicji jest logiczne sprawdzenie, czy strukturalnie poprawny fragment danych jest logicznie poprawny.
Na przykład, data urodzenia studenta może być strukturalnie poprawna poprzez posiadanie wartości `1/1/1800`, ale logicznie, student, który ma ponad 200 lat jest niemożliwy.

Najczęstszymi logicznymi walidacjami są walidacje dla pól audytu takich jak `CreatedBy` i `UpdatedBy` - jest logicznie niemożliwe, że nowy rekord może być wstawiony z dwoma różnymi wartościami dla autorów tego nowego rekordu - po prostu dlatego, że dane mogą być wstawione tylko przez jedną osobę w tym samym czasie.

Porozmawiajmy o tym, jak możemy przetestować i zaimplementować logiczne walidacje:

##### 2.1.3.1.3.0 Testowanie walidacji logicznych.

W powszechnym przypadku testowania logicznych walidacji dla pól audytu, chcemy rzucić wyjątek walidacji, że wartość `UpdatedBy` jest nieważna tylko dlatego, że nie pasuje do pola `CreatedBy`.

Załóżmy, że nasz model Student wygląda następująco:

```csharp
public class Student {
	Guid CreatedBy {get; set;}
	Guid UpdatedBy {get; set;}
}
```

Nasz test, aby zatwierdzić te wartości logicznie, byłby następujący:

```csharp
[Fakt]
public async Task ShouldThrowValidationExceptionOnRegisterIfUpdatedByNotSameAsCreatedByAndLogItAsync()
{
	// dana
	Student randomStudent = CreateRandomStudent();
	Student inputStudent = randomStudent;
	inputStudent.UpdatedBy = Guid.NewGuid();

	var invalidStudentException = new InvalidStudentException();

	invalidStudentException.AddData(
		key: nameof(Student.UpdatedBy),
		value: $"Id nie jest takie samo jak {nameof(Student.CreatedBy)}.");

	var expectedStudentValidationException =.
		new StudentValidationException(invalidStudentException);

	// gdy
	ValueTask<Student> registerStudentTask =.
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentValidationException actualStudentValidationException =.
		await Assert.ThrowsAsync<StudentValidationException>(
			registerStudentTask.AsTask);

	// następnie
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.loggingBrokerMock.Verify(broker =>.
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException)),
				Times.Once);

	this.storageBrokerMock.Verify(broker =>.
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Never);

	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.dateTimeBrokerMock.VerifyNoOtherCalls();
	this.storageBrokerMock.VerifyNoOtherCalls();
}
```

W powyższym teście zmieniliśmy wartość pola `UpdatedBy`, aby zapewnić, że całkowicie różni się od pola `CreatedBy` - teraz spodziewamy się wyjątku `InvalidStudentException` z `CreatedBy`, który będzie powodem wystąpienia tego wyjątku walidacji.

Idźmy dalej i napiszmy implementację dla tego nieudanego testu.

##### 2.1.3.1.3.1 Implementacja logicznej walidacji

Tak jak zrobiliśmy to w sekcji walidacji strukturalnych, dodamy więcej reguł do naszej walidacji `switch case` w następujący sposób:

###### StudentService.Validations.cs

```csharp
private void ValidateStudent(Student student)
{
	Validate(
		(Reguła: IsNotSame(
			firstId: student.UpdatedBy,
			secondId: student.CreatedBy,
			secondIdName: nameof(student.CreatedBy)),
		Parameter: nameof(Student.UpdatedBy))
	);
}

private static dynamic IsNotSame(
	Guid firstId,
	Guid secondId,
	string secondIdName) => new
	{
		Condition = firstId != secondId,
		Message = $"Id nie jest takie samo jak {secondIdName}."
	};

private void Validate(params (dyanamic Rule, string Parameter)[] validations)
{
	var invalidStudentException = new Exception();

	foreach((reguła dynamiczna, parametr string) in validations)
	{
		if(reguła.Warunek)
		{
			invalidStudentException.UpsertData(
				key: parametr,
				value: rule.Message);
		}
	}
}
```

Wszystko inne zarówno w `StudentService.cs` jak i `StudentService.Exceptions.cs` kontynuuje dokładnie to samo, co zrobiliśmy powyżej w walidacjach strukturalnych.

Wyjątki walidacji logicznej, podobnie jak wszelkie inne wyjątki, które mogą wystąpić, są zazwyczaj niekrytyczne. Jednak wszystko zależy od Twojego przypadku biznesowego, aby określić, czy dana logiczna, strukturalna lub nawet zależna walidacja są krytyczne czy nie, to jest, kiedy możesz potrzebować stworzyć specjalną klasę wyjątków, coś jak `InvalidStudentCriticalException`, a następnie odpowiednio je zalogować.

#### 2.1.3.1.4 Walidacje zewnętrzne

Ostatnim rodzajem walidacji, które są zazwyczaj wykonywane przez usługi fundacji są walidacje zewnętrzne. Definiuję zewnętrzne walidacje jako każdą formę walidacji, która wymaga wywołania zewnętrznego zasobu w celu sprawdzenia czy usługa fundacji powinna kontynuować przetwarzanie przychodzących danych lub zatrzymać się z wyjątkiem.

Dobrym przykładem walidacji zależności jest sytuacja, gdy wywołujemy brokera, aby pobrać konkretną encję po jej id. Jeśli zwrócony podmiot nie zostanie znaleziony, lub broker API zwróci błąd `NotFound` - usługa fundacji jest wtedy zobowiązana do zawinięcia tego błędu w wyjątek `ValidationException` i zatrzymuje wszystkie następujące procesy.

Zewnętrzne wyjątki walidacji mogą wystąpić, jeśli zwrócona wartość nie odpowiadała oczekiwaniom, takim jak pusta lista zwrócona z wywołania API podczas próby wstawienia nowego trenera zespołu - jeśli nie ma członków zespołu, nie może być na przykład trenera. Usługa fundacji w tym przypadku będzie musiała podnieść lokalny wyjątek, aby wyjaśnić problem, coś jak `NoTeamMembersFoundException` lub coś o tym charakterze.

Napiszmy nieudany test dla zewnętrznego przykładu walidacji:

##### 2.1.3.1.4.0 Testowanie zewnętrznych walidacji.

Załóżmy, że próbujemy pobrać studenta z `Id`, który nie pasuje do żadnego rekordu w bazie danych. Oto jak moglibyśmy przetestować ten scenariusz. Po pierwsze, zdefiniujmy model `NotFoundStudentException` w następujący sposób:

```csharp
using Xeption;

public class NotFoundStudentException : Xeption
{
	public NotFoundStudentException(Guid id)
		: base (message: $"Couldn't find a student with id: {id}.")
	{}
}
```

Powyższy model to aspekt lokalizacyjny obsługi problemu. Teraz napiszmy nieudany test w następujący sposób:

```csharp
public async Task ShouldThrowValidationExceptionOnRetrieveByIdIfStudentNotFoundAndLogItAsync()
{
	// dana
	Guid randomStudentId = Guid.NewGuid();
	Guid inputStudentId = randomStudentId;
	Student noStudent = null;

	var notFoundStudentException =.
		new NotFoundStudentException(inputStudentId);

	var expectedStudentValidationException =.
		new StudentValidationException(notFoundStudentException);

	this.storageBrokerMock.Setup(broker =>.
		broker.SelectStudentByIdAsync(inputStudentId))
			.ReturnsAsync(noStudent);

	// kiedy
	ValueTask<Student> retrieveStudentByIdTask =.
		this.studentService.RetrieveStudentByIdAsync(inputStudentId);

	StudentValidationException actualStudentValidationException =.
		await Assert.ThrowsAsync<StudentValidationException>(
			retrieveStudentByIdTask.AsTask);

	// następnie
	actualStudentValidationException.Should().BeEquivalentTo(
		expectedStudentValidationException);

	this.storageBrokerMock.Verify(broker =>.
		broker.SelectStudentByIdAsync(inputStudentId),
			Times.Once);

	this.loggingBrokerMock.Verify(broker =>.
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentValidationException)),
				Times.Once);

	this.storageBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
	this.dateTimeBrokerMock.VerifyNotOtherCalls();
}
```

Powyższy test wymaga od nas rzucenia zlokalizowanego wyjątku jak w `NotFoundStudentException`, gdy broker magazynowy nie zwraca żadnych wartości dla danego `studentId`, a następnie zawinięcia lub skategoryzowania tego w `StudentValidationException`.

Wybieramy zawijanie zlokalizowanego wyjątku w wyjątek walidacji, a nie w wyjątek walidacji zależności, ponieważ inicjacja błędu pochodzi z naszej usługi, a nie z zasobu zewnętrznego. Jeśli zewnętrzny zasób jest źródłem błędu, musielibyśmy skategoryzować to jako wyjątek `DependencyValidationException`, który omówimy wkrótce.

Teraz przejdźmy do części implementacyjnej, aby nasz test przeszedł.

##### 2.1.3.1.4.1 Implementacja zewnętrznych walidacji

Aby zaimplementować zewnętrzną walidację będziemy musieli dotknąć wszystkich różnych aspektów naszej usługi. Podstawowa logika, walidacja i aspekty obsługi wyjątków są następujące.

Po pierwsze, zbudujmy funkcję walidacji, która wyrzuci wyjątek `NotFoundStudentException` jeśli przekazany parametr będzie miał wartość null.

###### StudentService.Validations.cs

```csharp
private static void VerifyStudentExists(Student maybeStudent, Guid studentId)
{
	if (maybeStudent is null)
	{
		throw new NotFoundStudentException(studentId);
	}
}
```

Ta implementacja zajmie się wykryciem problemu i wystawieniem lokalnego wyjątku `NotFoundStudentException`. Teraz przeskoczmy do aspektu obsługi wyjątków w naszym serwisie.

###### StudentService.Exceptions.cs

```csharp
private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	..
	catch (NotFoundStudentException notFoundStudentException)
	{
		throw CreateAndLogValidationException(notFoundStudentException);
	}
}

private StudentValidationException CreateAndLogValidationException(Exception exception)
{
	var studentValidationException = new StudentValidationException(exception);
	this.loggingBroker.LogError(studentValidationException);

	return studentValidationException;
}
```

Powyższa implementacja zajmie się kategoryzowaniem wyjątku `NotFoundStudentException` do `StudentValidationException`. Ostatnią częścią jest złożenie elementów w całość w następujący sposób.

###### StudentService.cs

```csharp
public ValueTask<Student> RetrieveStudentByIdAsync(Guid studentId) =>.
TryCatch(async () =>.
{
	ValidateStudentId(studentId);

	Student maybeStudent =
		await this.storageBroker.SelectStudentByIdAsync(studentId);

	ValidateStudentExists(maybeStudent, studentId);

	return maybeStudent;
});
```

Powyższa implementacja zapewni, że id jest prawidłowe, ale co ważniejsze, że cokolwiek zwróci `storageBroker` zostanie sprawdzone czy jest to obiekt czy `null`. Następnie należy wystawić wyjątek.

Istnieją sytuacje, w których próba pobrania encji, a następnie odkrycie, że ona nie istnieje, nie musi być błędna. W tym miejscu pojawiają się usługi przetwarzania, które wykorzystują logikę biznesową wyższego rzędu, aby poradzić sobie z tym bardziej złożonym scenariuszem.

#### 2.1.3.1.5 Walidacje zależności

Wyjątki walidacji zależności mogą wystąpić, ponieważ wywołałeś zewnętrzny zasób i zwrócił on błąd, lub zwrócił wartość, która uzasadnia podniesienie błędu. Na przykład, wywołanie API może zwrócić kod `404`, i to jest interpretowane jako wyjątek, jeśli wejście miało odpowiadać istniejącemu obiektowi.

Bardziej powszechnym przykładem jest sytuacja, gdy określony podmiot wejściowy używa tego samego id, co istniejący podmiot w systemie. W świecie relacyjnej bazy danych zostałby rzucony wyjątek duplicate key. W scneario RESTful API, programowo stosując tę samą koncepcję, osiąga również ten sam cel dla walidacji API zakładając, że granularność wywoływanego systemu osłabia integralność referencyjną ogólnych danych systemu.

Istnieją sytuacje, w których wadliwa odpowiedź może być wyrażona w sposób inny niż wyjątki, ale poruszymy ten temat w bardziej zaawansowanych rozdziałach tego Standardu.

Napiszmy test zawodny, aby sprawdzić, czy rzucamy wyjątek `DependencyValidationException`, jeśli model `Student` istnieje już w magazynie z brokerem pamięci masowej rzucającym wyjątek `DuplicateKeyException` jako natywny wynik operacji.

##### 2.1.3.1.5.0 Testowanie walidacji zależności

Załóżmy, że nasz model studenta używa `Id` z typem `Guid` w następujący sposób:

```csharp
public class Student
{
	public Guid Id {get; set;}
	public string Name {get; set;}
}
```

nasz test jednostkowy sprawdzający poprawność wyjątku `DependencyValidation` zostałby rzucony w sytuacji `DuplicateKey` wyglądałby następująco:

```csharp.
[Fact]
public async void ShouldThrowDependencyValidationExceptionOnRegisterIfStudentAlreadyExistsAndLogItAsync()
{
	// dana
	Student someStudent = CreateRandomStudent();
	string someMessage = GetRandomMessage();
	var duplicateKeyException = new DuplicateKeyException(exceptionMessage);

	var alreadyExistsStudentException =.
		new AlreadyExistsStudentException(duplicateKeyException);

	var expectedStudentDependencyValidationException =.
		new StudentDependencyValidationException(alreadyExistsStudentException);

	this.storageBrokerMock.Setup(broker =>.
		broker.InsertStudentAsync(It.IsAny<Student>())
			.ThrowsAsync(duplicateKeyException);

	// gdy
	ValueTask<Student> registerStudentTask =.
		this.studentService.RegisterStudentAsync(inputStudent);

	StudentDependencyValidationException actualStudentDependencyValidationException =.
		await Assert.ThrowsAsync<StudentDependencyValidationException>(
			registerStudentTask.AsTask);

	// następnie
	actualStudentDependencyValidationException.Should().BeEquivalentTo(
		expectedStudentDependencyValidationException);

	this.storageBrokerMock.Verify(broker =>.
		broker.InsertStudentAsync(It.IsAny<Student>()),
			Times.Once);

	this.loggingBrokerMock.Verify(broker =>.
		broker.LogError(It.Is(SameExceptionAs(
			expectedStudentDependencyValidationException)),
				Times.Once);

	this.storageBrokerMock.VerifyNoOtherCalls();
	this.loggingBrokerMock.VerifyNoOtherCalls();
}
```

W powyższym teście sprawdzamy, czy zawijamy natywny wyjątek `DuplicateKeyException` w lokalny model dostosowany do konkretnego przypadku modelu, który jest `AlreadyExistsStudentException` w naszym przykładzie tutaj. następnie zawijamy to ponownie z generycznym modelem wyjątku kategorii, który jest `StudentDependencyValidationException`.

Istnieje kilka zasad, które rządzą budową walidacji zależności, które są następujące:

- Reguła 1: Jeśli walidacja zależności obsługuje inną walidację zależności z usługi downstream, to wyjątek wewnętrzny wyjątku downstream powinien być taki sam dla walidacji zależności na bieżącym poziomie.

Innymi słowy, jeśli jakiś `StudentService` rzuca wyjątek `StudentDependencyValidationException` do usługi upstream, takiej jak `StudentProcessingService` - to ważne jest, aby `StudentProcessingDependencyValidationException` zawierał ten sam wewnętrzny wyjątek, co `StudentDependencyValidationException`. Dzieje się tak dlatego, że gdy te wyjątki zostaną zmapowane do komponentów ekspozycji, takich jak kontroler API lub komponenty UI, oryginalny komunikat walidacyjny musi propagować się przez system i być prezentowany użytkownikowi końcowemu bez względu na to, skąd pochodzi.

Dodatkowo, utrzymanie oryginalnego wewnętrznego wyjątku gwarantuje możliwość przekazywania różnych komunikatów o błędach przez punkty końcowe API. Na przykład, `AlreadyExistsStudentException` może być przekazywany jako `Conflict` lub `409` na poziomie kontrolera API - różni się to od innego wyjątku walidacji zależności, takiego jak `InvalidStudentReferenceException`, który byłby przekazywany jako błąd `FailedDependency` lub `424`.

- Zasada 2: Jeśli wyjątek walidacji zależności obsługuje wyjątek walidacji nie będący zależnością, powinien przyjąć ten wyjątek jako swój wewnętrzny wyjątek, a nie cokolwiek innego.

Te zasady zapewniają, że tylko lokalny wyjątek walidacji jest tym, co jest propagowane, a nie rodzimy wyjątek z systemu przechowywania lub API lub jakiejkolwiek innej zewnętrznej zależności.

Tak jest w przypadku naszego wyjątku `AlreadyExistsStudentException` i wyjątku `StudentDependencyValidationException` - rodzimy wyjątek jest całkowicie ukryty, a mapowanie rodzimego wyjątku i jego wewnętrzna wiadomość jest tym, co jest przekazywane użytkownikowi końcowemu. Daje to inżynierom możliwość kontrolowania tego, co jest przekazywane z drugiego końca ich systemu, zamiast pozwalać na propagację natywnej wiadomości (która może ulec zmianie) do użytkowników końcowych.

##### 2.1.3.0.5.1 Wdrażanie walidacji zależności

W zależności od tego skąd pochodzi błąd walidacji, implementacja walidacji zależności może lub nie może zawierać żadnej logiki biznesowej. Jak wspomnieliśmy wcześniej, jeśli błąd pochodzi z zewnętrznego zasobu (co ma miejsce w tym przypadku) - wtedy wszystko co musimy zrobić to po prostu zawinąć ten błąd w lokalny wyjątek, a następnie skategoryzować go z zewnętrznym wyjątkiem w ramach walidacji zależności.

Aby upewnić się, że wspomniany test przeszedł, będziemy potrzebowali kilku modeli.
Dla `AlreadyExistsStudentException` implementacja wyglądałaby następująco:

```csharp
public class AlreadyExistsStudentException : Exception
{
	public AlreadyExistsStudentException(Exception innerException)
		: base($"Student o tym samym Id już istnieje", innerException){ }
}
```

Potrzebujemy również wyjątku `StudentDependencyValidationException`, który powinien wyglądać następująco:

```csharp
public class StudentDependencyValidationException : Exception
{
	public StudentDependencyValidationException(Exception innerException)
		: base($"Wystąpił błąd walidacji zależności studenta, proszę spróbować ponownie.", innerException){ }
}

```

Teraz przejdźmy do strony implementacji, zacznijmy od logiki obsługi wyjątków:

###### StudentService.Exceptions.cs

```csharp
private delegate ValueTask<Student> ReturningStudentFunction();

private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
{
	try
	{
		return await returningStudentFunction();
	}
	...
	catch (DuplicateKeyException duplicateKeyException)
	{
		var alreadyExistsStudentException = new AlreadyExistsStudentException(duplicateKeyException);
		throw CreateAndLogDependencyValidationException(alreadyExistsStudentException);
	}
}

...

private StudentDependencyValidationException CreateAndLogDependencyValidationException(Exception exception)
{
	var StudentDependencyValidationException = new StudentDependencyValidationException(exception);
	this.loggingBroker.LogError(studentDependencyValidationException);

	return StudentDependencyValidationException;
}
```

Stworzyliśmy lokalny wewnętrzny wyjątek w bloku catch naszego procesu obsługi wyjątków, aby umożliwić ponowne wykorzystanie naszej metody wyjątku sprawdzania poprawności zależności w innych sytuacjach, które wymagają tego samego poziomu wyjątków zewnętrznych.

Wszystko inne pozostaje bez zmian, jeśli chodzi o odwołanie do metody `TryCatch` w pliku `StudentService.cs`.

### 2.1.3.2 Mapowanie

Drugą odpowiedzialnością usługi fundacji jest odgrywanie roli mapera w obie strony pomiędzy modelami lokalnymi i nielokalnymi. Na przykład, jeśli korzystasz z usługi poczty elektronicznej, która zapewnia własne SDK do integracji, a twoje brokery już owijają i eksponują interfejsy API dla tej usługi, twoja usługa fundacji jest wymagana do mapowania wejść i wyjść metod brokera do modeli lokalnych. ta sama sytuacja i częściej między natywnymi nielokalnymi wyjątkami, takimi jak te, które wymieniliśmy powyżej z sytuacją sprawdzania poprawności zależności, ten sam aspekt dotyczy tylko błędów zależności lub błędów usługi, jak omówimy wkrótce.

#### 2.1.3.2.0 Modele nielokalne

Bardzo często nowoczesne aplikacje wymagają w pewnym momencie integracji z usługami zewnętrznymi. Usługi te mogą być lokalne dla całej architektury lub systemu rozproszonego, w którym żyje aplikacja, lub mogą być dostawcami zewnętrznymi, takimi jak niektóre z popularnych usług poczty elektronicznej.
Dostawcy usług zewnętrznych inwestują wiele wysiłku w rozwój płynnych interfejsów API, SDK i bibliotek w każdym popularnym języku programowania, aby ułatwić inżynierom integrację swoich aplikacji z tą usługą strony trzeciej. Na przykład załóżmy, że zewnętrzny dostawca usług poczty elektronicznej oferuje następujący interfejs API poprzez swoje SDK:

```csharp
public interface IEmailServiceProvider
{
	ValueTask<EmailMessage> SendEmailAsync(EmailMessage message);
}
```

Rozważmy, że model `EmailMessage` jest modelem natywnym, pochodzi z SDK dostawcy usług e-mail. twoje brokery mogą oferować wrapper wokół tego API, budując kontrakt, aby wyabstrahować _funkcjonalność_, ale nie może zrobić wiele z natywnymi modelami, które są przekazywane lub zwracane z tych funkcjonalności. dlatego nasz interfejs brokerów wyglądałby coś takiego:

```csharp
public interface IEmailBroker (ang.)
{
	ValueTask<EmailMessage> SendEmailMessageAsync(EmailMessage message);
}
```

Wtedy implementacja byłaby czymś takim:

```csharp
public class EmailBroker : IEmailBroker
{
	public async ValueTask<EmailMessage> SendEmailMessageAsync(EmailMessage message) =>.
		await this.emailServiceProvider.SendEmailAsync(message);
}
```

Jak już mówiliśmy, brokerzy wykonali tutaj swoją część abstrakcji, odsuwając faktyczną implementację i zależności natywnego `EmailServiceProvider` od naszych serwletów fundacyjnych. Ale to tylko 50% pracy, abstrakcja nie jest jeszcze w pełni kompletna dopóki nie ma śladów natywnego modelu `EmailMessage`. W tym miejscu pojawiają się usługi fundacji, które wykonują sterowaną testami operację mapowania pomiędzy natywnymi nielokalnymi modelami a lokalnymi modelami Twojej aplikacji. Dlatego też bardzo możliwe jest zobaczenie funkcji mapowania w usłudze fundacji, aby odizolować natywny model od reszty usług warstwy biznesowej.

Twoja usługa fundacji będzie następnie wymagana do obsługi nowego modelu lokalnego, nazwijmy go `Email`. właściwości twojego lokalnego modelu mogą być identyczne z zewnętrznym modelem `EmailMessage` - zwłaszcza na poziomie prymitywnego typu danych. Ale nowy model byłby jedynym i jedynym kontraktem między twoją czystą warstwą logiki biznesowej (usługi przetwarzania, orkiestracji, koordynacji i zarządzania) a twoją hybrydową warstwą logiczną, taką jak usługi fundacji. Oto fragment kodu dla tej operacji:

```csharp
public async ValueTask<Email> SendEmailMessageAsync(Email email)
{
	EmailMessage inputEmailMessage = MapToEmailMessage(email);
	EmailMessage sentEmailMessage = await this.emailBroker.SendEmailMessageAsync(inputEmailMessage);

	return MapToEmail(sentEmailMessage);
}

```

W zależności od tego, czy zwrócona wiadomość ma status lub chciałbyś zwrócić wiadomość wejściową jako znak udanej operacji, obie praktyki są ważne w moim Standardzie. Wszystko zależy od tego, co ma więcej sensu dla operacji, którą próbujesz wykonać. powyższy snippet kodu jest idealnym scenariuszem, w którym twój kod będzie próbował pozostać wierny wartości przekazanej, jak również wartości zwróconej ze wszystkimi niezbędnymi mapowaniami w zestawie.

#### 2.1.3.2.1 Mapowania wyjątków

Podobnie jak modele nielokalne, wyjątki, które są produkowane przez zewnętrzne API, takie jak modele EntityFramework `DbUpdateException` lub jakiekolwiek inne muszą być mapowane do lokalnych modeli wyjątków.
Obsługa tych nielokalnych wyjątków, które wcześnie przed wejściem do komponentów warstwy czysto biznesowej, zapobiegnie potencjalnemu ścisłemu sprzężeniu lub zależności od jakiegokolwiek zewnętrznego modelu. jak to może być bardzo powszechne, że wyjątki mogą być obsługiwane inaczej w oparciu o typ wyjątku i jak chcemy sobie z nim poradzić wewnętrznie w systemie.
Na przykład, jeśli próbujemy obsłużyć wyjątek `UserNotFoundException` rzucony z użycia Microsoft Graph na przykład, możemy niekoniecznie chcieć wyjść z całej procedury. możemy chcieć kontynuować poprzez dodanie użytkownika w jakimś innym magazynie dla przyszłego przetwarzania składania Graph.
Zewnętrzne API nie powinny wpływać na to, czy nasza wewnętrzna operacja powinna się zatrzymać czy nie. i dlatego obsługa wyjątków w warstwie Foundation jest gwarancją, że ten wpływ jest ograniczony w granicach obszaru obsługi zasobów zewnętrznych naszej aplikacji i nie ma żadnego wpływu na nasze podstawowe procesy biznesowe.
Poniższa ilustracja powinna nieco wyraźniej nakreślić obraz z tej perspektywy:
<br />

<p align=center>
<img src="https://user-images.githubusercontent.com/1453985/112714067-b7366a00-8e95-11eb-9bb7-a5a047640f4a.png" />
</p>
<br />

Oto kilka typowych scenariuszy mapowania rodzimych lub wewnętrznych lokalnych wyjątków do zewnętrznych wyjątków:

| Wyjątek | Wrap Inner Exception With | Wrap With | Poziom logu |.
| ------------------------------------- | -------------------------------- | ------------------------------------ | --------- |
| NullStudentException | - | StudentValidationException | Error |
| InvalidStudentException | - | StudentValidationException | Error |
| SqlException | FailedStudentStorageException | StudentDependencyException | Krytyczny |
| HttpResponseUrlNotFoundException | FailedStudentApiException | StudentDependencyException | Critical |
| HttpResponseUnauthorizedException | FailedStudentApiException | StudentDependencyException | Critical |
| NotFoundStudentException | - | StudentValidationException | Error |
| HttpResponseNotFoundException | NotFoundStudentException | StudentDependencyValidationException | Error |
| DuplicateKeyException | AlreadyExistsStudentException | StudentDependencyValidationException | Error |
| HttpResponseConflictException | AlreadyExistsStudentException | StudentDependencyValidationException | Error |
| ForeignKeyConstraintConflictException | InvalidStudentReferenceException | StudentDependencyValidationException | Error |
| DbUpdateConcurrencyException | LockedStudentException | StudentDependencyValidationException | Error |
| DbUpdateException | FailedStudentStorageException | StudentDependencyException | Error |
| HttpResponseException | FailedStudentApiException | StudentDependencyException | Error |
| Exception | FailedStudentServiceException | StudentServiceException | Error |

[*] [Standaryzacja walidacji i wyjątków](https://www.youtube.com/watch?v=Wtpxb7yPQP0)

[*] [Test-Driving Non-Circuit-Breaking Validations](https://www.youtube.com/watch?v=guJPrIQ0kJk)
