# 2.3 Usługi orkiestracji (Complex Higher Order Logic)

# # 2.3.0 Wprowadzenie

Usługi orkiestracji są kombinatorami pomiędzy wieloma usługami fundacji lub przetwarzania w celu wykonania złożonej operacji logicznej. Ich główne obowiązki to wielopodmiotowe operacje logiczne i delegowanie zależności tych operacji do dalszych usług przetwarzania lub usług fundamentowych.

Podstawową odpowiedzialnością usług orkiestracji jest hermetyzacja operacji wymagających dwóch lub trzech podmiotów gospodarczych.

```csharp
public async ValueTask<LibraryCard> CreateStudentLibraryCardAsync(LibraryCard libraryCard) =>.
TryCatch(async () =>.
{
    ValidateLibraryCard(libraryCard);

    await this.studentProcessingService
        .VerifyEnrolledStudentExistsAsync(libraryCard.StudentId);

    return await this.libraryCardProcessingService.CreateLibraryCardAsync(libraryCard);
});

```

W powyższym przykładzie `LibraryCardOrchestrationService` wywołuje zarówno `StudentProcessingService` jak i `LibraryCardProcessingService` w celu wykonania złożonej operacji. Po pierwsze, zweryfikować istnienie studenta, dla którego tworzymy kartę biblioteczną, oraz sprawdzić zapisy studenta; a po drugie, stworzyć kartę biblioteczną.

Operacja tworzenia karty bibliotecznej dla danego studenta nie może być wykonana przez zwykłe wywołanie usługi karty bibliotecznej; ponieważ usługa karty bibliotecznej (przetwarzanie lub fundacja) nie ma dostępu do wszystkich szczegółów dotyczących studenta. Dlatego wymagana jest logika kombinacyjna, aby zapewnić odpowiedni przepływ.

Ważne jest, aby zrozumieć, że usługi orkiestracji są wymagane tylko wtedy, gdy musimy połączyć operacje wielopodmiotowe, które mogą być prymitywne lub wyższego rzędu. W niektórych architekturach usługi orkiestracji mogą nawet nie istnieć. Jest tak po prostu dlatego, że niektóre mikroserwisy mogą być jedynie odpowiedzialne za stosowanie logiki walidacji oraz utrzymywanie i pobieranie danych z pamięci masowej, ni mniej ni więcej.

## 2.3.1 Na mapie

Usługi orkiestracji są jednym z podstawowych komponentów logiki biznesowej w każdym systemie, umiejscowionym pomiędzy usługami pojedynczego podmiotu (takimi jak przetwarzanie lub fundacja) a zaawansowanymi usługami logiki, takimi jak usługi koordynacji, usługi agregacji lub po prostu eksponenty takie jak kontrolery komponentów webowych lub cokolwiek innego. Oto wysokopoziomowy przegląd tego, gdzie mogą żyć usługi orkiestracji:

<br />
    <p align="center" >.
        <img src="https://user-images.githubusercontent.com/1453985/118414675-e4fc8b80-b65a-11eb-91c8-94f67c6e68ed.png" />
    </p>
<br />

Jak pokazano powyżej, usługi Orchestration mają sporo zależności i konsumentów. Są one podstawowym silnikiem każdego oprogramowania. Po prawej stronie można zobaczyć zależności usługi orkiestracji. Ponieważ usługa przetwarzania jest opcjonalna w oparciu o to, czy potrzebna jest logika biznesowa wyższego rzędu, czy nie - usługi orkiestracji mogą również łączyć wiele usług fundamentowych.

Istnienie usługi Orchestration gwarantuje obecność usługi Processing. Nie zawsze jednak tak jest. Istnieją sytuacje, w których wszystkie usługi orkiestracji muszą sfinalizować przepływ biznesowy, aby wejść w interakcję z funkcjonalnością na poziomie prymitywnym.

Jednak usługa orkiestracji może mieć kilku konsumentów, takich jak usługi koordynacyjne (orkiestratorzy orkiestratorów), usługi agregacji lub po prostu eksponent. Ekspozytorzy są jak kontrolery, usługi widoku, komponenty UI lub inny fundament lub usługa przetwarzania w przypadku odkładania wiadomości z powrotem do kolejki - co omówimy dalej w naszym Standardzie.

## 2.3.2 Charakterystyka

Ogólnie rzecz biorąc, usługi orkiestracji zajmują się łączeniem jednopodmiotowych prymitywnych lub wyższego rzędu operacji logiki biznesowej w celu wykonania udanego przepływu. Ale można również myśleć o nich jako o kleju, który wiąże razem wiele operacji pojedynczych podmiotów.

### 2.3.2.0 Język

Podobnie jak usługi Processing, język używany w usługach Orchestration określa poziom złożoności i możliwości, jakie oferuje.
Zazwyczaj usługi orkiestracji łączą dwie lub więcej operacji prymitywnych lub wyższego rzędu z wielu usług single-entity w celu wykonania udanej operacji.

#### 2.3.2.0.0 Język funkcji

Usługi orkiestracji mają wspólną cechę dotyczącą języka ich funkcji. Usługi orkiestracji są wholistic w większości języka swojej funkcji. Zobaczysz funkcje takie jak `NotifyAllAdmins`, gdzie usługa pobiera wszystkich użytkowników z typem administratora, a następnie wywołuje usługę powiadamiania, aby ich powiadomić.

Usługi orkiestracji oferują funkcjonalność, która coraz bardziej zbliża się do języka biznesowego niż prymitywnych operacji technicznych. Możesz zobaczyć prawie identyczne wyrażenie w nietechnicznym wymaganiu biznesowym pasującym do nazwy funkcji w usłudze orkiestracji. Ten sam wzór kontynuuje się w miarę przechodzenia do wyższych i bardziej zaawansowanych kategorii usług w ramach tej sfery logiki biznesowej.

#### 2.3.2.0.1 Pass-Through

Usługi orkiestracji mogą być również przepustką dla niektórych operacji. Na przykład, usługa orkiestracji może pozwolić na propagację `AddStudentAsync` przez usługę, aby ujednolicić źródło interakcji z systemem na poziomie eksponentów. W tym przypadku usługi orkiestracji będą używać tej samej terminologii, której może użyć usługa przetwarzania lub fundacji, aby propagować operację.

#### 2.3.2.0.2 Class-Level Language

Usługi orkiestracji głównie łączą wiele operacji obsługujących daną encję. Jeśli więc podstawową encją jest `Student`, a pozostałe encje mają tylko wspierać operację skierowaną głównie na encję `Student` - wówczas nazwa usługi orkiestracji brzmiałaby `StudentOrchestrationService`.

Egzekwowanie konwencji nazewnictwa zapewnia, że każda usługa orkiestracji pozostaje skoncentrowana na odpowiedzialności pojedynczej encji dotyczącej wielu innych podmiotów wspierających.

Na przykład, tworzenie karty bibliotecznej wymaga zapisania do szkoły ucznia, do którego odnosi się ta karta biblioteczna. W tym przypadku, nazwa usługi orkiestracji będzie odzwierciedlać jej główną jednostkę, `LibraryCard`. Naszą nazwą usługi orkiestracji będzie wtedy `LibraryCardOrchestrationService`.

Odwrotna sytuacja jest również prawdziwa. Jeśli zapisanie ucznia do szkoły ma powiązane operacje, takie jak tworzenie karty bibliotecznej, to w tym przypadku musi istnieć `StudentOrchestrationService`, aby utworzyć `Studenta` i wszystkie inne powiązane encje.

Ta sama idea dotyczy wszystkich wyjątków tworzonych w usłudze orkiestracji, takich jak `StudentOrchestrationValidationException` i `StudentOrchestrationDependencyException`.

### 2.3.2.1 Zależności

Jak wspomnieliśmy, usługi Orchestration mogą mieć bardziej rozbudowany zakres zależności, w przeciwieństwie do usług Processing i Foundation, ze względu na opcjonalność usług Processing. Dlatego też usługi Orchestration mogą mieć zależności od usług fundamentowych lub opcjonalnych usług przetwarzania do usług przekrojowych, takich jak logowanie lub inne brokery użytkowe.

#### 2.3.2.1.0 Równowaga zależności (Wzorzec Florance)

Podstawową zasadą regulującą spójność i równowagę usług orkiestracji jest "Wzorzec Florance", który nakazuje, że dowolna usługa orkiestracji nie może łączyć zależności z różnych kategorii działania.

Oznacza to, że usługa Orchestration nie może łączyć usług Foundation i Processing. Zależności muszą być albo wszystkie Processingi, albo wszystkie usługi Foundation. Ta zasada nie dotyczy jednak zależności brokerów użyteczności.

Oto przykład niezrównoważonych zależności usługi orkiestracji:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/118415856-9e5e5f80-b661-11eb-96db-a541f89ccee7.png" />
    </p>
<br />

Dodatkowa usługa przetwarzania jest wymagana, aby dać przejście do usługi fundamentowej niższego poziomu, aby zrównoważyć architekturę - zastosowanie 'Florance Pattern' dla symetrii zmieniłoby naszą architekturę na następującą:

<br />
    <p align="center" >
        <img src="https://user-images.githubusercontent.com/1453985/118415965-33f9ef00-b662-11eb-8538-59e5c728d308.png" />
    </p>
<br />

Zastosowanie "Florance Pattern" może być bardzo kosztowne na początku, ponieważ obejmuje stworzenie całkowicie nowej usługi przetwarzania (lub wielu) w celu zrównoważenia architektury. Ale jego korzyści przewyższają koszty z punktu widzenia utrzymania, czytelności i możliwości podłączenia.

#### 2.3.2.1.1 Two-Three

Reguła "Two-Three" jest regułą kontroli złożoności. Reguła ta nakazuje, że usługa orkiestracji nie może mieć więcej niż trzy lub mniej niż dwie usługi przetwarzania lub fundacji, aby uruchomić orkiestrację. Reguła ta nie dotyczy jednak brokerów użyteczności. I usługa orkiestracji może mieć `DateTimeBroker` lub `LoggingBroker` bez żadnych problemów. Ale usługa orkiestracji nie może mieć brokera encji, takiego jak `StorageBroker` lub `QueueBroker`, który zasila bezpośrednio podstawową warstwę biznesową dowolnej usługi.

Reguła "Dwa-trzy" może wymagać warstwy normalizacji do kategorycznej funkcji biznesowej. Porozmawiajmy o różnych mechanizmach normalizacji usług orkiestracji.

##### 2.3.2.1.0 Pełna normalizacja

Często zdarzają się sytuacje, w których aktualna architektura dowolnej usługi orkiestracji kończy się na jednej usłudze orkiestracji z trzema zależnościami. A do zakończenia istniejącego procesu wymagana jest nowa usługa przetwarzania encji lub fundacji.

Na przykład, powiedzmy, że mamy `StudentContactOrchestrationService` i ta usługa ma zależności, które zapewniają funkcjonalność na poziomie prymitywnym dla `Address`, `Email` i `Phone` dla każdego studenta. Oto wizualizacja tego stanu:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120101834-f636a500-c0fc-11eb-968b-10ed9a60bac8.png" />
    </p>
<br />

Teraz nowe wymaganie "SocialMedia" jest dodane do "Student", aby zebrać więcej informacji kontaktowych o tym, jak dotrzeć do studenta. Możemy przejść do trybu pełnej normalizacji po prostu znajdując wspólną płaszczyznę, która równo dzieli encje informacji kontaktowych. Na przykład, możemy rozdzielić zwykłe informacje kontaktowe od cyfrowych informacji kontaktowych, jak w `Adresie` i `Phone` od `Emaila` i `SocialMedia`. W ten sposób dzielimy cztery zależności na dwie, każda dla swoich usług orkiestracji w następujący sposób:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120101983-c6d46800-c0fd-11eb-836a-496d191ef922.png" />
    </p>
<br />

Na powyższym rysunku zmodyfikowaliśmy istniejący `StudentContactOrchestrationService` na `StudentRegularContactOrchestrationService` i usunęliśmy jedną z jego zależności od `EmailService`.

Dodatkowo stworzyliśmy nowy `StudentDigitalContactOrchestrationService`, aby miał dwie zależności od istniejącego `EmailService` i nowego `SocialMediaService`. W związku z tym, potrzebujemy teraz zaawansowanej warstwy logiki biznesowej, jak usługa koordynacji, aby dostarczyć informacje kontaktowe studentów do konsumentów upstream.

##### 2.3.2.1.1 Semi-normalizacja

Normalizacja nie zawsze jest tak prosta jak powyższy przykład, zwłaszcza gdy podstawowa encja musi istnieć przed utworzeniem lub wypełnieniem dodatkowych informacji o powiązanych encjach.

Na przykład, powiedzmy, że mamy `StudentRegistrationOrchestrationService`, który opiera się na `StudentProcessingService`, `LibraryCardProcessingService` i `BookProcessingService` w następujący sposób:

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120099527-c41f4600-c0f0-11eb-8702-1439f966d9dc.png" />
    </p>
<br />

Ale teraz potrzebujemy nowej usługi do obsługi rekordów immunizacji studentów jako `ImmunizationProcessingService`. Potrzebujemy wszystkich czterech usług, ale mamy już usługę `StudentRegistrationOrchestrationService`, która ma trzy zależności. W tym momencie, półnormalizacja jest wymagana do ponownego zrównoważenia architektury, aby uhonorować zasadę "dwa-trzy" i ostatecznie kontrolować złożoność.

<br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120100296-ea46e500-c0f4-11eb-888a-ed6668e9ffdb.png" />
    </p>
<br />

W tym przypadku wymagana jest dalsza normalizacja lub podział w celu ponownego zrównoważenia architektury. Musimy myśleć koncepcyjnie o wspólnej płaszczyźnie między prymitywnymi jednostkami w procesie rejestracji studentów. Wymagania studenckie zawierają tożsamość, zdrowie i materiały. Możemy, w tym scenariuszu, połączyć `LibraryCard` i `Book` w ramach tej samej usługi orkiestracji, ponieważ książki i biblioteki są w pewien sposób powiązane. Mamy więc `StudentLibraryOrchestrationService,` a dla drugiej usługi mielibyśmy `StudentHealthOrchestrationService` w następujący sposób:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120100597-68f05200-c0f6-11eb-9ccc-ae1c963f6de5.png" />
    </p>
 <br />

Aby zakończyć przepływ rejestracji z nowym modelem, usługa koordynacji musi przekazać zaawansowaną logikę biznesową, aby połączyć te podmioty. Ale co ważniejsze, zauważysz, że każda usługa orkiestracji ma nadmiarową zależność `StudentProcessingService`, aby zapewnić brak wirtualnej zależności od jakiejkolwiek innej usługi orkiestracji, tworząc / zapewniając, że rekord studenta istnieje.

Wirtualne zależności są bardzo zdradliwe. Jest to ukryte połączenie między dwoma usługami dowolnej kategorii, w którym jedna usługa domyślnie zakłada, że określony podmiot będzie utworzony i obecny. Wirtualne zależności są bardzo niebezpieczne i zagrażają właściwej autonomii każdej usługi. Wykrywanie wirtualnych zależności na wczesnym etapie procesu projektowania i rozwoju może być zniechęcającym, ale koniecznym zadaniem, aby zapewnić czystą, znormalizowaną architekturę.

Podobnie jak zmiany modelu wymagają migracji struktury bazy danych oraz dodatkowej logiki i walidacji, nowe wymaganie dotyczące nowego podmiotu może wymagać restrukturyzacji istniejącej architektury lub rozszerzenia jej do nowej wersji, w zależności od tego, na jakim etapie system otrzymuje te nowe wymagania.

Dodanie kolejnej zależności do istniejącej usługi orkiestracji może być bardzo kuszące - ale w tym miejscu system zaczyna odbiegać od "Standardu". I właśnie wtedy system zaczyna stawać się niemożliwym do utrzymania systemem legacy. Ale co ważniejsze, ten scenariusz testuje zasady projektowania i standardy rzemiosła inżynierów zaangażowanych w projektowanie i rozwój systemu.

##### 2.3.2.1.1.2 Brak normalizacji

Wierzę, że wszystko, wszędzie, w jakiś sposób jest połączone. Jednak istnieją scenariusze, w których wyższe poziomy normalizacji są wyzwaniem do osiągnięcia. Czasami niezrozumiałe dla umysłu może być zgrupowanie wielu usług pod jedną usługą orkiestracji.

Ponieważ jest to dość trudne dla mojego umysłu, aby wymyślić przykład dla wielu podmiotów, które nie mają ze sobą żadnego połączenia, ponieważ autentycznie wierzę, że nie może istnieć. Zamierzam polegać na niektórych fikcyjnych podmiotach, aby zwizualizować problem. Załóżmy więc, że istnieją `AService` i `BService` orkiestrowane razem z `XService`. Istnienie `XService` jest ważne, aby zapewnić, że zarówno `A`, jak i `B` mogą być tworzone z zapewnieniem, że podmiot główny `X` istnieje.

Teraz powiedzmy, że nowa usługa `CService` jest wymagana do dodania do mieszanki, aby zakończyć istniejący przepływ. Tak więc, teraz mamy cztery różne zależności w ramach jednej usługi orkiestracji, a podział jest obowiązkowy. Ponieważ nie ma żadnych relacji między `A`, `B` i `C`, podejście "No-Normalization" staje się jedyną opcją, aby zrealizować nowy projekt, jak poniżej:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/120102975-4d8b4400-c102-11eb-9582-6f95d17227e7.png" />
    </p>
 <br />

Każda z powyższych prymitywnych usług będzie orkiestrowana z usługą główną `X`, a następnie zebrana pod usługą koordynacyjną. Powyższy przypadek to najgorszy scenariusz, w którym normalizacja dowolnej wielkości jest niemożliwa. Zauważ, że autor tego Standardu nie mógł wymyślić realistycznego przykładu niepodobnego do innych, aby pokazać, jak rzadko można natknąć się na tę sytuację, więc niech podejście "No-Normalization" będzie twoim bardzo ostatnim rozwiązaniem, jeśli zabraknie ci opcji.

##### 2.3.2.1.3 Znaczący podział
Niezależnie od rodzaju normalizacji, którą podążasz, musisz zapewnić, że twoje zgrupowane usługi reprezentują wspólne znaczenie. Na przykład, łączenie `StudentProcessingService` i `LibraryProcessingService` musi wymagać funkcjonalnej wspólności. Dobrym przykładem może być na przykład `StudentRegistrationOrchestrationService`. Proces rejestracji wymaga dodania nowego rekordu studenta i utworzenia karty bibliotecznej dla tego samego studenta.

Implementacja usług orkiestracji bez skrzyżowania pomiędzy dwoma lub trzema podmiotami na operację pokonuje cały cel posiadania usługi orkiestracji. Warunek ten jest spełniony, jeśli wystąpiło co najmniej jedno przecięcie między dwoma podmiotami. Usługa orkiestracji może mieć inne operacje "Pass-Through", w których propagujemy pewne procedury z ich pochodzenia przetwarzania lub fundacji, jeśli pasują do tego samego kontraktu.

Oto przykład:

```csharp
public class StudentOrchestrationService
{
    public async ValueTask<Student> RegisterStudentAsync(Student Student)
    {
        Student addedStudent =.
            await this.studentProcessingService.AddStudentAsync(student);
    
        LibraryCard libraryCard =
            await this.libraryCardPorcessingService.AddLibraryCardAsync(
                addedStudent.Id);

        return addedStudent;
    }


    public async ValueTask<Student> ModifyStudentAsync(Student student) =>.
        await this.studentProcessingService.ModifyStudentAsync(student);
}
```

W powyższym przykładzie nasza `StudentOrchestrationService` posiadała rutynę orkiestracji, która łączyła dodawanie studenta i tworzenie karty bibliotecznej dla tego studenta. Ale dodatkowo oferuje również funkcję "Pass-Through" dla niskopoziomowej rutyny usługi przetwarzania w celu modyfikacji studenta.

Rutyny 'Pass-Through' muszą mieć ten sam kontrakt, co inne procedury w każdej usłudze orkiestracji. Nasza zasada 'Pure Contract' dyktuje, że każda usługa powinna zezwalać na ten sam kontrakt jako wejście i wyjście lub prymitywne typy.

### 2.3.2.2 Kontrakty
Usługi orkiestracji mogą łączyć dwa lub trzy różne podmioty i ich operacje, aby osiągnąć wyższą logikę biznesową. Istnieją dwa scenariusze kontraktów/modeli dla usług orkiestracji: Jeden, który pozostaje wierny celowi podstawowej jednostki; i jeden, który jest złożony - usługa orkiestracji kombinatorycznej, która próbuje jawnie ujawnić swoje wewnętrzne jednostki docelowe.

Porozmawiajmy o tych dwóch scenariuszach w szczegółach.

#### 2.3.2.0 Kontrakty fizyczne
Niektóre usługi orkiestracji są nadal jednopozycyjne, mimo że mogą łączyć dwie lub trzy inne procedury wyższego rzędu z wielu podmiotów. Na przykład, usługa orkiestracji, która reaguje na wiadomości z jakiejś kolejki, a następnie utrzymuje te wiadomości, są usługami orkiestracji o pojedynczym przeznaczeniu i pojedynczym podmiocie.

Przyjrzyjmy się temu fragmentowi kodu:

```csharp

public class StudentOrchestrationService (ang.)
{
    private readonly IStudentEventProcessingService studentEventProcessingService;
    private readonly IStudentProcessingService studentProcessingService;

    public StudentOrchestrationService(
        IStudentEventProcessingService studentEventProcessingService,
        IStudentProcessingService studentProcessingService)
    {
        this.studentEventProcessingService = studentEventProcessingService;
        this.studentProcessingService = studentProcessingService;
        ListenToEvents();
    }

    public void ListenToEvents() =>.
        this.studentEventService.ListenToEvent(UpsertStudentAsync);

    public async ValueTask<Student> UpsertStudentAsync(Student student)
    {
        ...
        await this.StudentProcessingService.UpsertStudentAsync(student);

        ...
    }
}
```

W powyższym przykładzie usługa orkiestracji nadal eksponuje funkcjonalność, która honoruje model fizyczny `Student` i wewnętrznie komunikuje się z kilkoma usługami, które mogą dostarczać zupełnie inne modele. Są to scenariusze, w których pojedynczy podmiot ma główny cel, a wszystkie inne usługi są usługami wspierającymi, aby zapewnić udany przepływ dla tego podmiotu.

W naszym przykładzie usługi orkiestracji _słuchają_ kolejki dla wiadomości o nowych studentach, a następnie używają tego zdarzenia do utrzymywania wszelkich przychodzących nowych studentów w systemie. Tak więc fizyczny kontrakt `Student` jest tym samym językiem, którego usługa orkiestracji jawnie używa jako modelu do komunikacji z górnymi usługami strumieniowymi/ekspozytorami lub innymi.

Ale istnieją inne scenariusze, w których pojedynczy podmiot nie jest jedynym celem / celem dla usługi orkiestracji. Porozmawiajmy o tym szczegółowo.

#### 2.3.2.1 Kontrakty wirtualne
W niektórych scenariuszach usługa orkiestracji może być wymagana do tworzenia kontraktów niefizycznych w celu wykonania określonej operacji. Na przykład, rozważ usługę orkiestracji wymaganą do utrzymania postu w mediach społecznościowych zawierającego zdjęcie. Wymagane jest, aby zdjęcie było przechowywane w jednej bazie danych, a rzeczywisty post (komentarze, autorzy i inne) w innej tabeli bazy danych w modelu relacyjnym.

Model przychodzący może znacznie różnić się od rzeczywistych modeli fizycznych. Zobaczmy, jak wyglądałoby to w prawdziwym świecie.

Rozważmy posiadanie takiego modelu:

```csharp
public class MediaPost
{
    public Guid Id {get; set;}
    public string Content {get; set;}
    public DateTimeOffset Date {get; set;}
    public IEnumerable<string> Base64Images {get; set;}
}
```

Powyższy kontrakt `MediaPost` zawiera dwie różne fizyczne jednostki połączone. Pierwszym z nich jest rzeczywisty post, zawierający `Id`, `Content` i `Date`, a drugim lista obrazów dołączonych do tego właśnie postu.

Oto jak usługa orkiestracji zareagowałaby na ten przychodzący wirtualny model:

```csharp
public async ValueTask<MediaPost> SubmitMediaPostAsync(MediaPost mediaPost)
{
    ...

    Post post = MapToPost(mediaPost);
    List<Media> medias = MapToMedias(mediaPost);

    Post addedPost =.
        await this.postProcessingService.AddPostAsync(post);
    
    List<Medias> addedMedias =.
        await this.mediaProcessingService.AddMediasAsync(medias);

    return MapToMediaPost(addedPost, addedMedias);
}

public Post MapToPost(MediaPost mediaPost)
{
    return new Post
    {
        Id = mediaPost.Id,
        Content = mediaPost.Content,
        CreatedDate = mediaPost.Date,
        UpdatedDate = mediaPost.Date
    };
}

public List<Media> MapToMedias(MediaPost mediaPost)
{
    return mediaPost.Base64Images.Select(image =>.
        new Media
        {
            Id = Guid.NewGuid(),
            PostId = mediaPost.Id,
            Image = image,
            CreatedDate = mediaPost.Date,
            UpdatedDate = mediaPost.Date
        });
}
```

Powyższy fragment kodu pokazuje usługę orkiestracji dekonstruującą dany wirtualny model/kontrakt `MediaPost` na dwa fizyczne modele. Każdy z nich ma swoją osobną usługę przetwarzania, która obsługuje jego persystencję. Istnieją scenariusze, w których model wirtualny zostaje zdekonstruowany do jednego modelu z dodatkowymi szczegółami używanymi do walidacji i weryfikacji z usługami przetwarzania lub fundacji.

Istnieją również sytuacje hybrydowe, w których przychodzący model wirtualny może mieć zagnieżdżone modele fizyczne, co jest czymś, na co możemy pozwolić tylko w przypadku modeli wirtualnych. Modele fizyczne powinny pozostać anemiczne (nie zawierają żadnych procedur ani konstruktorów) i płaskie (nie zawierają zagnieżdżonych modeli) przez cały czas, aby kontrolować złożoność i skupić odpowiedzialność.

Podsumowując, usługi Orchestration mogą tworzyć własne kontrakty. Kontrakty te mogą być fizyczne lub wirtualne. A kontrakt wirtualny może być kombinacją jednego lub wielu fizycznych (lub zagnieżdżonych wirtualnych) kontraktów lub po prostu ma swój własny płaski projekt pod względem właściwości.

### 2.3.2.2 Cul-De-Sac
Czasami usługi Orchestration i ich odpowiedniki (koordynacja, zarządzanie itp.) Mogą nie potrzebować komponentu eksportera (kontrolera, na przykład). Dzieje się tak, ponieważ usługi te mogą być słuchaczami określonych zdarzeń i przekazują zdarzenie z powrotem do usługi Processing lub Foundation na tym samym poziomie, na którym zdarzenie się rozpoczęło lub zostało odebrane.

Na przykład przychodzące wiadomości mogą być odbierane z subskrypcji usługi zdarzeń lub kolejki. W tym przypadku wejście do tych usług nie musi już odbywać się za pośrednictwem komponentu eksponującego. Wyobraź sobie, że budujesz prostą aplikację, w której otrzymuje ona powiadomienia z wiadomościami z kolejki, a następnie mapuje te wiadomości do jakiegoś lokalnego modelu, aby utrwalić go w pamięci masowej. W tym przypadku usługa orkiestracji wyglądałaby coś takiego jak poniżej:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/144501231-11ea13c9-81fa-4730-8840-a891a1d9edde.png" />
    </p>
 <br />

 Usługa `StudentEventOrchestrationService` nasłuchuje wiadomości o przychodzących nowych studentach i od razu konwertuje to na modele, które mogą być uporczywie przechowywane w bazie danych.

 Oto przykład:

 Zacznijmy od testu jednostkowego dla tego wzorca w następujący sposób:
 ```csharp
[Fact]
public void ShouldListenToProfileEvents()
{
    // podany . gdy
    this.profileEventOrchestrationService.ListenToProfileEvents();

    // then
    this.profileEventServiceMock.Verify(service =>.
        service.ListenToProfileEvent(
            this.profileEventOrchestrationService.ProcessProfileEventAsync),
                Times.Once);

    this.profileEventService.VerifyNoOtherCalls();
    this.profileServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
}

[Fakt]
public async Task ShouldAddProfileAsync()
{
    // dana
    ProfileEvent randomProfileEvent =.
        CreateRandomProfileEvent();

    ProfileEvent inputProfileEvent =.
        randomProfileEvent;

    this.profileServiceMock.Setup(service =>.
        service.AddProfileAsync(inputProfileEvent.Profile));

    // when
    await this.profileEventOrchestrationService
        .ProcessProfileEventAsync(inputProfileEvent);

    // then
    this.profileServiceMock.Verify(service =>.
        service.AddProfileAsync(inputProfileEvent.Profile),
            Times.Once);

    this.profileServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
    this.profileEventServiceMock.VerifyNoOtherCalls();
}
 ```

 Test tutaj wskazuje, że najpierw musi wystąpić nasłuchiwanie zdarzeń, a następnie logika persystencji w usłudze studenta musi odpowiadać wynikowi mapowania przychodzącej wiadomości do danego studenta.

 Spróbujmy sprawić, aby ten test przeszedł.

 ```csharp
public partial class ProfileEventOrchestrationService : IProfileEventOrchestrationService
{
    private readonly IProfileEventService profileEventService;
    private readonly IProfileService profileService;
    private readonly ILoggingBroker loggingBroker;

    public ProfileEventOrchestrationService(
        IProfileEventProcessingService profileEventService,
        IProfileProcessingService profileService,
        ILoggingBroker loggingBroker)
    {
        this.profileEventService = profileEventService;
        this.profileService = profileService;
        this.loggingBroker = loggingBroker;
    }

    public void ListenToProfileEvents() =>.
    TryCatch(() =>.
    {
        this.profileEventService.ListenToProfileEvent(
            ProcessProfileEventAsync);
    });

    public ValueTask ProcessProfileEventAsync(ProfileEvent profileEvent) =>.
    TryCatch(async () =>.
    {
        ...

        await this.profileService.AddProfileAsync(profileEvent.Profile);
    });
}
 ```

W powyższym przykładzie konstruktor usługi orkiestracji subskrybuje zdarzenia, które pochodziłyby z usługi `StudentEventService`. Gdy wystąpi zdarzenie, usługa orkiestracji wywoła funkcję `ProcessingIncomingStudentMessageAsync`, aby utrwalić przychodzącego studenta w bazie danych poprzez fundację lub usługę przetwarzania na tym samym poziomie co usługa zdarzeń.

Ten wzorzec lub właściwość nazywa się Cul-De-Sac. Przychodząca wiadomość będzie skręcać i kierować się w innym kierunku dla innej zależności. Ten wzór jest typowy w dużych aplikacjach na poziomie przedsiębiorstwa, gdzie ewentualna spójność jest włączona, aby zapewnić, że system może skalować i stać się odporny w warunkach dużego zużycia. Ten wzorzec zapobiega również złośliwym atakom na punkty końcowe API, ponieważ pozwala na przetwarzanie wiadomości z kolejki lub zdarzeń, gdy tylko usługa jest gotowa do ich przetwarzania. Szczegóły omówimy w "Architekturze wzorca".

## 2.3.3 Zakres odpowiedzialności
Usługi orkiestracji dostarczają zaawansowanej logiki biznesowej. Orkiestruje ona wiele przepływów dla wielu podmiotów/modeli, aby zakończyć pojedynczy przepływ. Omówmy szczegółowo, jakie są te odpowiedzialności:

### 2.3.3.0 Zaawansowana logika
Usługi orkiestracji nie mogą istnieć bez łączenia wielu rutyn z wielu podmiotów. Podmioty te mogą różnić się charakterem, ale mają wspólny przepływ lub cel. Na przykład `LibraryCard` jako model jest zasadniczo różny od modelu `Student`. Jednak obie mają wspólny cel dotyczący procesu rejestracji studentów. Dodanie rekordu studenta jest wymagane do rejestracji studenta, ale przypisanie karty bibliotecznej do tego studenta jest wymagane dla udanego procesu rejestracji studenta.

Usługi orkiestracji zapewniają, że właściwe procedury dla każdej jednostki są zintegrowane, ale także zapewniają, że te procedury są wywoływane w prawidłowej kolejności. Dodatkowo, usługi orkiestracji są odpowiedzialne za cofanie nieudanej operacji. Te trzy aspekty stanowią wysiłek orkiestracji w ramach wielu procedur, podmiotów lub kontraktów.

Porozmawiajmy o nich szczegółowo.

#### 2.3.3.0.0 Kombinacje przepływów
Mówiliśmy wcześniej o usługach orkiestracji łączących wiele procedur w celu osiągnięcia wspólnego celu lub pojedynczego przepływu. Ten aspekt usług orkiestracji może służyć zarówno jako podstawowa cecha, jak i odpowiedzialność. Usługa orkiestracji bez co najmniej jednej rutyny łączącej dwa lub trzy podmioty nie jest uważana za orkiestrację. Integracja z wieloma usługami bez wspólnego celu jest lepiej dopasowaną definicją dla usług Aggregation, które omówimy w dalszej części tego rozdziału dotyczącego usług.

Ale w ramach łączenia przepływów dochodzi do ujednolicenia kontraktu. Nazywam to mapowaniem i rozgałęzianiem. Mapowanie modelu przychodzącego na wiele modeli usług niższego strumienia następnie rozgałęzienie odpowiedzialności w poprzek tych usług.

Podobnie jak poprzednie usługi, podczas ich łączenia przepływów, usługi Orchestration są odpowiedzialne za zapewnienie czystości eksponowanych kontraktów wejściowych i wyjściowych, co staje się nieco bardziej złożone podczas łączenia wielu modeli. Usługi orkiestracji nadal będą odpowiedzialne za mapowanie przychodzących kontraktów do ich odpowiednich usług downstream. Będą również mapować z powrotem zwrócone wyniki z tych usług do zunifikowanego modelu.

Przywołajmy poprzedni wycinek kodu, aby zilustrować ten aspekt:

```csharp
public async ValueTask<MediaPost> SubmitMediaPostAsync(MediaPost mediaPost)
{
    ...

    Post post = MapToPost(mediaPost);
    List<Media> medias = MapToMedias(mediaPost);

    Post addedPost =.
        await this.postProcessingService.AddPostAsync(post);
    
    List<Medias> addedMedias =.
        await this.mediaProcessingService.AddMediasAsync(medias);

    return MapToMediaPost(addedPost, addedMedias);
}

private Post MapToPost(MediaPost mediaPost)
{
    return new Post
    {
        Id = mediaPost.Id,
        Content = mediaPost.Content,
        CreatedDate = mediaPost.Date,
        UpdatedDate = mediaPost.Date
    };
}

private List<Media> MapToMedias(MediaPost mediaPost)
{
    return mediaPost.Base64Images.Select(image =>.
        new Media
        {
            Id = Guid.NewGuid(),
            PostId = mediaPost.Id,
            Image = image,
            CreatedDate = mediaPost.Date,
            UpdatedDate = mediaPost.Date
        });
}

private MediaPost MapToMediaPost(Post post, List<Media> medias)
{
    return new MediaPost
    {
        Id = post.Id,
        Content = post.Content,
        Date = post.CreatedDate,
        Base64Images = medias.Select(media => media.Image)
    }
}
```
Jak widać w powyższym przykładzie, mapowanie i rozgałęzienie nie dzieje się tylko w drodze do środka. Ale odwrotne działanie musi być podjęte na drodze do wyjścia. To narusza The Standard, aby zwrócić ten sam obiekt wejściowy, który został przekazany. To zabiera wszelką widoczność na potencjalne zmiany w przychodzącym żądaniu podczas persystencji. Mapowanie dupleksowe powinno zastąpić potrzebę dereferencji przychodzącego żądania, aby upewnić się, że nie nastąpiły żadne nieoczekiwane zmiany wewnętrzne.

Zauważ, że rozbicie logiki mapowania na własny aspekt / plik klasy częściowej jest również zalecane. Coś jak `StudentOrchestrationService.Mappings.cs`, aby zapewnić, że jedyną rzeczą, która pozostała, jest logika biznesowa orkiestracji.

#### 2.3.3.0.1 Kolejność wywoływania
Wywoływanie procedur w odpowiedniej kolejności może być kluczowe dla każdego procesu orkiestracji. Na przykład, karta biblioteczna nie może zostać utworzona, jeśli najpierw nie zostanie utworzony rekord studenta. Wymuszanie kolejności w tym miejscu może podzielić się na dwa różne typy. Porozmawiajmy o nich tutaj przez chwilę.

##### 2.3.3.0.1.0 Naturalny porządek
Naturalny porządek odnosi się tutaj do specyficznych przepływów, które nie mogą być wykonane, jeśli nie zostanie pobrany lub utrzymany wstępny warunek parametrów wejściowych. Na przykład, wyobraźmy sobie sytuację, w której karta biblioteczna nie może zostać utworzona, jeśli najpierw nie zostanie pobrany unikalny identyfikator studenta. W tym przypadku nie musimy się martwić o testowanie, czy określone procedury zostały wywołane w odpowiedniej kolejności, ponieważ jest to naturalnie związane z przepływem.

Oto przykład kodu dla tej sytuacji:

```csharp
public async ValueTask<LibraryCard> CreateLibraryCardAsync(LibraryCard libraryCard)
{
    Student student = await this.studentProcessingService
        .RetrieveStudentByIdAsync(libraryCard.StudentId));

    return await this.libraryCardProcessingService
        .CreateLibraryCardAsync(libraryCard, student.Name);
}
```
W powyższym przykładzie posiadanie studenta `Name` jest wymogiem do stworzenia karty bibliotecznej. Dlatego orkiestracja porządku tutaj przychodzi naturalnie jako część przepływu bez dodatkowego wysiłku.

Porozmawiajmy teraz o drugim typie porządku - Enforced Order.

##### 2.3.3.0.1.1 Wymuszony porządek
Wyobraźmy sobie ten sam przykład powyżej, ale zamiast karty bibliotecznej wymagającej nazwy studenta, potrzebuje ona tylko studenta `Id` już zamkniętego w modelu przychodzącego żądania. Coś w tym stylu:

```csharp
public async ValueTask<LibraryCard> CreateLibraryCardAsync(LibraryCard libraryCard)
{
    await this.StudentProcessingService.VerifyEnlistedStudentExistAsync(
        libraryCard.StudentId);

    return await this.libraryCardProcessingService.CreateLibraryCardAsync(libraryCard);
}
```

Zapewnienie, że zweryfikowany zapisany student istnieje przed utworzeniem karty bibliotecznej może stać się wyzwaniem, ponieważ nie ma zależności między wartością zwrotną jednej rutyny a parametrami wejściowymi następnej. Innymi słowy, nie ma nic, co zwraca funkcja `VerifyEnlistedStudentExistAsync`, o co dba funkcja `CreateLibraryCardAsync` w zakresie parametrów wejściowych.

W tym przypadku tutaj wymuszony rodzaj porządku musi być zaimplementowany poprzez testy jednostkowe. Test jednostkowy dla tej rutyny wymagałby sprawdzenia nie tylko tego, że zależność została wywołana z prawidłowymi parametrami, ale także tego, że są one wywoływane w prawidłowym _porządku_ Przyjrzyjmy się, jak to byłoby zaimplementowane:

```csharp
[Fakt]
public async Task ShouldCreateLibraryCardAsync()
{
    // dana
    Student someStudent = CreateRandomStudent();
    LibraryCard randomLibraryCard = CreateRandomLibraryCard();
    LibraryCard inputLibraryCard = randomLibraryCard;
    LibraryCard createdLibraryCard = inputLibraryCard;
    LibraryCard expectedLibraryCard = inputLibraryCard.DeepClone();
    Guid studentId = inputLibraryCard.StudentId;
    var mockSequence = new MockSequence();

    this.StudentProcessingServiceMock.InSequence(mockSequence).Setup(service =>.
        service.VerifyEnlistedStudentExistAsync(studentId))
            .Returns(someStudent);

    this.libraryCardProcessingServiceMock.InSequence(mockSequence).Setup(service =>.
        service.CreateLibraryCardAsync(inputLibraryCard))
            .ReturnsAsync(createdLibraryCard);

    // kiedy
    LibraryCard actualLibraryCard = await this.libraryCardOrchestrationService
        .CreateLibraryCardAsync(inputLibraryCard);

    // then
    actualLibraryCard.Should().BeEquivalentTo(expectedLibraryCard);

    this.StudentProcessingServiceMock.Verify(service =>.
        service.VerifyEnlistedStudentExistAsync(studentId),
            Times.Once);

    this.libraryCardProcessingServiceMock.Verify(service =>.
        service.CreateLibraryCardAsync(inputLibraryCard),
            Times.Once);

    this.studentProcessingServiceMock.VerifyNoOtherCalls();
    this.libraryCardProcessingServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
}

```

Z powyższego przykładu wynika, że framework mock jest tutaj używany do zapewnienia określonego porządku podczas wywoływania tych zależności. W ten sposób wymuszamy pewną implementację w ramach dowolnej metody, aby zapewnić, że nienaturalnie połączone zależności są kolejno wywoływane w zamierzonej kolejności.

Jest bardziej prawdopodobne, że typ zamawiania skłania się bardziej w kierunku wymuszonym niż naturalnym, gdy usługi orkiestracji osiągną maksymalną liczbę zależności.

#### 2.3.3.0.2 Mapowanie wyjątków (Wrapping & Unwrapping)
Ta odpowiedzialność jest bardzo podobna do kombinacji przepływów. Z tym, że w tym przypadku usługi orkiestracji unifikują wszystkie wyjątki, które mogą wystąpić z dowolnej jej zależności w jeden zunifikowany model wyjątków kategorycznych. Zacznijmy od ilustracji, jak może wyglądać to mapowanie:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/145294325-0818a2dd-a017-43af-b1f0-fa5c93a9218c.png" />
    </p>
 <br />

Na powyższej ilustracji można zauważyć, że wyjątki walidacji i walidacji zależności, rzucane z usług zależnościowych downstream, mapują się w jeden zunifikowany wyjątek zależności na poziomie orkiestracji. Ta praktyka pozwala konsumentom upstream tej samej usługi orkiestracji określić następny kierunek działania w oparciu o jeden kategoryczny typ wyjątku zamiast czterech lub w przypadku trzech zależności byłoby to sześć kategorycznych zależności.

Zacznijmy od nieudanego testu, aby zmaterializować nasz pomysł tutaj:

```csharp
public static TheoryData DependencyValidationExceptions()
{
    string exceptionMessage = GetRandomMessage();
    var innerException = new Xeption(exceptionMessage);

    var StudentValidationException =.
        new StudentValidationException(innerException);

    var studentDependencyValidationException =.
        new StudentDependencyValidationException(innerException);

    var libraryCardValidationException =.
        new LibraryCardValidationException(innerException);

    var libraryCardDependencyValidationException =.
        new LibraryCardDependencyValidationException(innerException);

    return new TheoryData<Xeption>.
    {
        studentValidationException,
        studentDependencyValidationException,
        libraryCardValidationException,
        libraryCardDependencyValidationException
    };
}


[Theory]
[MemberData(nameof(DependencyValidationExceptions))]
public async Task ShouldThrowDependencyValidationExceptionOnCreateIfDependencyValidationErrorOccursAndLogItAsync(
    Xeption dependencyValidationException)
{
    // dana
    Student someStudent = CreateRandomStudent();

    var expectedStudentOrchestrationDependencyValidationException =.
        new StudentOrchestrationDependencyValidationException(
            dependencyValidationException.InnerException as Xeption);

    this.StudentServiceMock.Setup(service =>.
        service.AddStudentAsync(It.IsAny<Student>())
            .ThrowsAsync(dependencyValidationException);

    // kiedy
    ValueTask<Student> addStudentTask =.
        await this.studentOrchestrationService.AddStudentAsync(someStudent);

    StudentOrchestrationDependencyValidationException
        actualStudentOrchestrationDependencyValidationException =.
                await Assert.ThrowsAsync<StudentOrchestrationDependencyValidationException>(
                    addStudentTask.AsTask);

    // następnie
    actualStudentOrchestrationDependencyValidationException.Should()
        .BeEquivalentTo(expectedStudentOrchestrationDependencyValidationException);

    this.StudentServiceMock.Verify(service =>.
        service.AddStudentAsync(It.IsAny<Student>()),
            Times.Once);

    this.loggingBrokerMock.Verify(broker =>.
        broker.LogError(It.Is(SameExceptionAs(
            expectedStudentOrchestrationDependencyValidationException)),
                Times.Once);

    this.libraryCardServiceMock.Verify(service =>.
        service.AddLibraryCard(It.IsAny<Guid>()),
            Times.Once);

    this.studentServiceMock.VerifyNoOtherCalls();
    this.loggingBrokerMock.VerifyNoOtherCalls();
    this.libraryCardServiceMock.VerifyNoOtherCalls();
}
```

Powyżej sprawdzamy, czy którykolwiek z naszych czterech typów wyjątków jest odwzorowany w `StudentOrchestrationDependencyValidationException`. Zachowujemy oryginalny zlokalizowany wyjątek jako wyjątek wewnętrzny. Ale rozpakowujemy kategoryczny wyjątek na tym poziomie, aby zachować oryginalny problem, gdy idziemy w górę rzeki.

Wyjątki te są mapowane w ramach wyjątku sprawdzania poprawności zależności, ponieważ pochodzą z zależności lub zależności zależności zależności downstream. Na przykład, jeśli broker pamięci masowej rzuca wyjątek, który jest walidacją zależności (coś jak `DuplicateKeyException`). Usługa sąsiadująca z brokerem mapowałaby to do zlokalizowanego wyjątku `StudentAlreadyExistException`, a następnie zawijała ten wyjątek w kategoryczny wyjątek typu `StudentDependencyValidationException`. Kiedy ten wyjątek propaguje się w górę rzeki do Processing lub usługi Orchestration, tracimy kategoryczny wyjątek, ponieważ już uchwyciliśmy go w odpowiednim zakresie mapowania. Następnie kontynuujemy osadzanie tego bardzo zlokalizowanego wyjątku pod bieżącym wyjątkiem walidacji zależności usług.

Spróbujmy sprawić, by ten test przeszedł:

```csharp
public partial class "StudentOrchestrationService
{
    private delegate ValueTask<Student> ReturningStudentFunction();

    private async ValueTask<Student> TryCatch(ReturningStudentFunction returningStudentFunction)
    {
        try
        {
            return await returningStudentFunction();
        }
        catch (StudentValidationException studentValidationException)
        {
            throw CreateAndLogDependencyValidationException(studentValidationException);
        }
        catch (StudentDependencyValidationException studentDependencyValidationException)
        {
            throw CreateAndLogDependencyValidationException(studentDependencyValidationException);
        }
        catch (LibraryCardValidationException libraryCardValidationException)
        {
            throw CreateAndLogDependencyValidationException(libraryCardValidationException);
        }
        catch (LibraryCardDependencyValidationException libraryCardDependencyValidationException)
        {
            throw CreateAndLogDependencyValidationException(libraryCardDependencyValidationException);
        }
    }

    private StudentOrchestrationDependencyValidationException CreateAndLogDependencyValidationException(Xeption exception)
    {
        var StudentOrchestrationDependencyValidationException =.
            new StudentOrchestrationDependencyValidationException(exception.innerException as Xeption);

        this.loggingBroker.LogError(studentOrchestrationDependencyValidationException);

        throw studentOrchestrationDependencyValidationException;
    }
}
```

Teraz możemy użyć `TryCatch` w następujący sposób:

```csharp
public async ValueTask<Student> AddStudentAsync(Student student) =>.
TryCatch(async () =>.
{
    ...
    Student addedStudent = await this.studentService.AddStudentAsync(student);
    LibraryCard libraryCard = await this.libraryCard.AddLibraryCard(addedStudent.Id);

    return addedStudent;
});
```

Możesz zobaczyć w implementacji, że zmapowaliśmy wszystkie cztery różne typy wyjątków walidacji zewnętrznych usług downstream w jeden wyjątek kategoryczny, a następnie utrzymaliśmy wewnętrzny wyjątek dla każdego z nich.

Ta sama zasada dotyczy wyjątków zależności. Wyjątki zależności mogą być zarówno wyjątkami usługi, jak i wyjątkami zależności od usług downstream. Na przykład w powyższym przykładzie wywołanie usługi studenta może spowodować powstanie wyjątków `StudentDependencyException` i `StudentServiceException`. Te kategoryczne wyjątki zostaną rozpakowane z ich warstwy kategorycznej i będą miały swoją lokalną warstwę zawiniętą w jeden zunifikowany nowy wyjątek kategoryczny na poziomie orkiestracji pod `StudentOrchestrationDependencyException`. To samo dotyczy wszystkich innych wyjątków kategorycznych zależności, takich jak `LibraryCardDependencyException` i `LibraryCardServiceException`.

Kluczowe jest rozpakowanie i zawinięcie zlokalizowanych wyjątków z usług downstream z kategorycznymi wyjątkami w bieżącej warstwie usług, aby zapewnić spójność z warstwą Exposers. Te wyjątki mogą być łatwo obsługiwane i mapowane na cokolwiek dyktuje natura komponentu Exposer. W przypadku komponentu Exposer typu API Controller, mapowanie dałoby kody stanu HTTP. W przypadku komponentów Exposer typu UI, mapowałoby to na tekst znaczący dla użytkowników końcowych.

Będziemy dyskutować dalej w tym Standardzie, kiedy eksponować zlokalizowane wewnętrzne szczegóły wyjątków, gdzie użytkownicy końcowi nie muszą podejmować żadnych działań, co jest wyłączne dla wyjątków zależności i poziomu usług.

## 2.3.4 Wariacje
Usługi orkiestracji różnią się w zależności od tego, gdzie stoją w ogólnej architekturze niskiego poziomu. Na przykład usługa orkiestracji zależna od usług orkiestracji downstream jest nazywana usługą koordynacji. Usługa orkiestracji działająca z wieloma usługami koordynacji jako zależnościami jest nazywana usługą zarządzania. Te warianty są usługą orkiestracji z logiką biznesową uber-level.

 ### 2.3.4.0 Poziomy wariantów
Przyjrzyjmy się możliwym wariantom dla usług orkiestracji i gdzie byłyby one pozycjonowane:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147461598-e7fe6b48-976a-4787-bd97-11e7faf131ee.png" />
    </p>
 <br />

 W moim osobistym doświadczeniu rzadko musiałem rozwiązać do usługi zarządzania Uberem. Ideą ograniczenia tutaj w zakresie zależności i odmian usług podobnych do orkiestracji jest pomoc inżynierom w ponownym przemyśleniu złożoności ich logiki. Ale przyznaj, że są sytuacje, w których złożoność jest absolutną koniecznością. Dlatego usługi Uber-Management istnieją jako opcja.

 Poniższa tabela powinna poprowadzić proces opracowywania wariantów usług orkiestracji w oparciu o poziom:

| Wariant | Zależności | Konsumentów | Złożoności |.
|------------------------ |--------------------------- | ------------------------------------------| -----------|
| Usługi orkiestracji | Usługi podstawowe lub przetwarzające | Usługi koordynacyjne | Niski poziom
| Usługi koordynacyjne | Usługi orkiestracji | Usługi zarządzania | Średni
| Usługi Zarządzania | Usługi Koordynacyjne | Usługi Zarządzania Uber | Wysoka |
| Usługi Zarządzania Uberem | Usługi Zarządzania | Komponenty Agregacji, Widoku lub Ekspozytora | Bardzo Wysoki | Bardzo Wysoki

 Praca poza usługami zarządzania Uber w sposób orkiestracji wymagałaby głębszej dyskusji i poważnego rozważenia ogólnej architektury. Przyszłe wersje Standardu mogą być w stanie zająć się tym problemem w tym, co nazywam "Domem nad jeziorem", ale to jest poza zakresem tej wersji Standardu.

 ### 2.3.4.1 Jednostka pracy
 Z odmianami usług orkiestracji, bardzo polecam pozostanie wiernym koncepcji jednostki pracy. Każde żądanie może zrobić jedną rzecz i tylko jedną rzecz, w tym jego warunki wstępne. Na przykład, jeśli musisz zarejestrować ucznia w szkole, możesz wymagać dodania opiekuna, informacji kontaktowych i innych szczegółów. Zdarzenie tych działań może znacznie zmniejszyć złożoność przepływu i obniżyć ryzyko awarii w usługach downstream.

 Oto wizualizacja dla złożonego podejścia jednowątkowego:

 <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147462984-84e6dabd-bf27-413a-8e79-2659a24c37c0.png" />
    </p>
 <br />

 Powyższe rozwiązanie jest działającym rozwiązaniem do rejestracji ucznia. Musieliśmy uwzględnić informacje o opiekunach, kartach bibliotecznych, zajęciach itp. Te zależności można rozbić na zdarzenia, pozwalając innym usługom odebrać, gdzie usługi jednowątkowe opuszczają, aby kontynuować proces rejestracji. Coś w tym stylu:


  <br />
    <p align=center>
        <img src="https://user-images.githubusercontent.com/1453985/147463233-466a055f-ce95-4911-92cd-7b173b2a37df.png" />
    </p>
  <br />

  Powyżej, przychodzące żądanie jest przekształcane w zdarzenia, gdzie każde z tych zdarzeń powiadamiałoby swoje usługi orkiestracji we wzorcu cul-de-sac, jak omówiono w sekcji 2.3.2.2. Oznacza to, że pojedynczy wątek nie jest już odpowiedzialny za sukces każdej zależności w systemie. Zamiast tego każdy broker nasłuchujący zdarzeń obsługiwałby swój proces w uproszczony sposób.

  Takie podejście nie gwarantuje natychmiastowej odpowiedzi o sukcesie lub porażce dla żądającego. Jest to wzorzec eventual-consistency, w którym klient otrzymałby wiadomość `Accepted` lub jej odpowiednik oparty na protokole komunikacyjnym, aby dać mu znać, że proces się rozpoczął. Nadal nie ma gwarancji wyników, dopóki cała logika zdarzeń nie zostanie wykonana.

  Zauważ, że możemy dodać dodatkową warstwę odporności do tych zdarzeń poprzez tymczasowe przechowywanie ich w komponentach podobnych do kolejki lub w tymczasowych magazynach opartych na pamięci; w zależności od krytyczności biznesu.

  Jednak podejście oparte na spójności zdarzeń nie zawsze jest dobrym rozwiązaniem, jeśli klient po drugiej stronie czeka na odpowiedź, szczególnie w sytuacjach krytycznych, gdzie wymagana jest natychmiastowa reakcja. Jednym z rozwiązań tego problemu są kolejki Fire-n-Observe, które omówimy w przyszłej wersji The Standard.
  
[*] [Wprowadzenie do Orchestration Services](https://www.youtube.com/watch?v=OP6HcIpXduE)

[*] [Wzorzec Cul-De-Sac dla Usług Orkiestracji](https://www.youtube.com/watch?v=C8Sm1kSKF1o)

[*] [Wzorzec Cul-De-Sac dla usług koordynacyjnych](https://www.youtube.com/watch?v=8KZIw_IJC0U)
